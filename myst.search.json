{"version":"1","records":[{"hierarchy":{"lvl1":"Tensile test analysis"},"type":"lvl1","url":"/data-practical-work","position":0},{"hierarchy":{"lvl1":"Tensile test analysis"},"content":"","type":"content","url":"/data-practical-work","position":1},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"General scope"},"type":"lvl2","url":"/data-practical-work#general-scope","position":2},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"General scope"},"content":"From global point of view, test machines, sensors provide time-stamped data.\nMost of the time this a data are stored in a tabular shape, i.e. one line for each record with its time-stamp.\n\nA common way to store this data is to use ‘.csv’ file. A '.cvs’ file looks like:time;data1;data2;data3\n0.0;12.;.001;'blue'\n0.1;11.5;.002;'red'\n0.2;14.2;.004;'blue'\n0.3;14.2;-.004;'green'\n...\n...\n...\n\nThe Pandas module is a convenient way to manage this file (read and write).\n\nIn addition, metadata can be stored in this file, at the beginning of the file.\nIn this metadata global info can be stored, as the date of the test, the name of the operator, the material, the sample type, commentary...\n\nA total file can look like:date : 01-02-1900\nuser : bob\nmaterial : Steel \nlength : .5\nremarks : This test is awsome\n\ntime;data1;data2;data3\n0.0;12.;.001;'blue'\n0.1;11.5;.002;'red'\n0.2;14.2;.004;'blue'\n0.3;14.2;-.004;'green'\n...\n...\n...","type":"content","url":"/data-practical-work#general-scope","position":3},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"Session objective"},"type":"lvl2","url":"/data-practical-work#session-objective","position":4},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"Session objective"},"content":"In this session you are asked to analyze data coming from the tensile test.\nThis analysis aims at extracting the mechanical properties of the material, such as the Young modulus, mechanical strength and yield strength from the load/displacement curve.\n\nAt the end of this session, you should have a class that is able to deal with the data coming from a tensile test.","type":"content","url":"/data-practical-work#session-objective","position":5},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"The dataset :"},"type":"lvl2","url":"/data-practical-work#the-dataset","position":6},{"hierarchy":{"lvl1":"Tensile test analysis","lvl2":"The dataset :"},"content":"Required files\n\nIt can be downloaded at this link \n\nTensileData.\n\nIt contains 4 files, the unit are s/N/mm :\n\nTest_1.csv\n\nTest_2.csv\n\nTest_3.csv\n\nTest_4.csv\n\n# Setup\n%matplotlib notebook\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n\n\n","type":"content","url":"/data-practical-work#the-dataset","position":7},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q1 : Load the data and plot its","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q1-load-the-data-and-plot-its","position":8},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q1 : Load the data and plot its","lvl2":"The dataset :"},"content":"code one function that loads one test\n\ncall this function 4 times to load all data\n\nplot all the tests on one figure\n\n\n\n\n\n","type":"content","url":"/data-practical-work#q1-load-the-data-and-plot-its","position":9},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q2: Load the metadata","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q2-load-the-metadata","position":10},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q2: Load the metadata","lvl2":"The dataset :"},"content":"Into the ‘.csv’ file the first 2 line provides S_0 and l_0 of each sample.\n\ncode a function that read this data\n\ncall this function on each test","type":"content","url":"/data-practical-work#q2-load-the-metadata","position":11},{"hierarchy":{"lvl1":"Tensile test analysis","lvl4":"Useful function","lvl3":"Q2: Load the metadata","lvl2":"The dataset :"},"type":"lvl4","url":"/data-practical-work#useful-function","position":12},{"hierarchy":{"lvl1":"Tensile test analysis","lvl4":"Useful function","lvl3":"Q2: Load the metadata","lvl2":"The dataset :"},"content":"Tip: split a string into 2 partsline = \"z = 143.2\"\nword1, word2 = line.split(\"=\")\n\n\n\n\n\n","type":"content","url":"/data-practical-work#useful-function","position":13},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q3: Stress/Strain curve","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q3-stress-strain-curve","position":14},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q3: Stress/Strain curve","lvl2":"The dataset :"},"content":"Knowing that:\n\n\\sigma_n = \\frac{F}{S0}\nand\n\n\\epsilon_n = \\frac{\\Delta L}{L_0}:\n\nCode a function that computes the strain and stress data.\n\nApply the function to all tests.\n\nPlot this data for all test on a graph.\n\n\n\n\n\n","type":"content","url":"/data-practical-work#q3-stress-strain-curve","position":15},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q4: Mechanilca strength","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q4-mechanilca-strength","position":16},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q4: Mechanilca strength","lvl2":"The dataset :"},"content":"Code a function that computes the mechanical strength.\n\nApply the function to all tests.\n\nPlot this data for all test on a graph.\n\n\n\n\n\n","type":"content","url":"/data-practical-work#q4-mechanilca-strength","position":17},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q5: Young modulus measurements","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q5-young-modulus-measurements","position":18},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q5: Young modulus measurements","lvl2":"The dataset :"},"content":"Code a function that computes the young modulus on each test.\n\nApply the function to all tests.\n\nPropose a plot to illustrate the young modulus measurements\n\ndef get_young_modulus(df):\n    E = 0.0\n    return E\n\n\n\n","type":"content","url":"/data-practical-work#q5-young-modulus-measurements","position":19},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q6: all together in a class","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q6-all-together-in-a-class","position":20},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q6: all together in a class","lvl2":"The dataset :"},"content":"Include all the function you have coded in a class.\n\nBelow is a simple template of the class that you should build :\n\nclass TensileTest:\n    \"\"\"\n    this class is able to ....\n    \"\"\"\n\n    def __init__(self, csv_file=\"xxx\"):\n        self.csv_file = csv_file\n        # CODDE HERE\n\n    def __repr__(self):\n        return \"<tensileTest: (file: {0}, E = {1:.2} MPa)>\".format(\n            self.csv_file, self.get_YoungModulus()\n        )\n\n    def get_meca_strength(self):\n        return 0.0\n\n    def get_YoungModulus(self):\n        # CODDE HERE\n        return 1.0\n\n\n\ntest1 = TensileTest(\"my_csv.csv\")  # call the __init__ function\n\n\n\ntest1  # call the __repr__ function\n\n\n\n","type":"content","url":"/data-practical-work#q6-all-together-in-a-class","position":21},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q7: The plastic side of the force","lvl2":"The dataset :"},"type":"lvl3","url":"/data-practical-work#q7-the-plastic-side-of-the-force","position":22},{"hierarchy":{"lvl1":"Tensile test analysis","lvl3":"Q7: The plastic side of the force","lvl2":"The dataset :"},"content":"compute the plastique strain (\\varepsilon_p = \\varepsilon - \\dfrac{\\sigma}{E} )\n\nfit the stress / plastic strain curve with a power plastic law (\\sigma = \\sigma_0 + K {\\varepsilon_p}^n )\n\n\n\n","type":"content","url":"/data-practical-work#q7-the-plastic-side-of-the-force","position":23},{"hierarchy":{"lvl1":"Analysis of data from a weather station"},"type":"lvl1","url":"/data-tutorial","position":0},{"hierarchy":{"lvl1":"Analysis of data from a weather station"},"content":"","type":"content","url":"/data-tutorial","position":1},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Context and Objectives"},"type":"lvl2","url":"/data-tutorial#context-and-objectives","position":2},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Context and Objectives"},"content":"The objective of this tutorial is to introduce the core steps of data processing and basic data analysis through the manipulation of a real-world temperature dataset of significant size.\nThe tutorial follows a pragmatic and progressive approach, focusing on essential tools and methods commonly used in engineering data analysis.\n\nThe work is structured around a typical data analysis workflow, starting from raw data and leading to quantitative indicators and graphical representations.\n\nBy completing this tutorial, students will be able to:\n\nLoad and explore a dataset: Import temperature data from external files using Python, inspect the structure of the dataset, and identify variables, data types, and basic formatting issues.\n\nPerform basic data cleaning operations: Handle missing values, filter time periods, select relevant variables, and apply simple transformations required for analysis.\n\nManipulate and aggregate data: Group data over time, compute annual averages, and extract relevant subsets needed for further analysis.\n\nCompute descriptive statistics: Calculate elementary statistical quantities such as mean values, extrema, and variability in order to characterize long-term temperature evolution.\n\nVisualize data for analysis and communication: Generate clear and informative plots, with particular emphasis on the construction of a Warming Stripe graphic, a compact visualization designed to communicate long-term temperature trends.","type":"content","url":"/data-tutorial#context-and-objectives","position":3},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Practical objective of the tutorial"},"type":"lvl2","url":"/data-tutorial#practical-objective-of-the-tutorial","position":4},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Practical objective of the tutorial"},"content":"Beyond the methodological aspects, the concrete objective of this tutorial is to produce a Warming Stripe visualization from raw temperature data.\nStudents will start from daily temperature measurements, process and aggregate the data, and finally generate a visual representation highlighting temperature anomalies over time.\n\n\n\nÉvolution des températures (“warming stripes”), source : [Wiki - Warming stripes](https://en.wikipedia.org/wiki/Warming_stripes) / WMO.\n\nThis final output illustrates how simple data processing and visualization choices can effectively convey complex information, and emphasizes the role of data analysis in scientific communication and dissemination.","type":"content","url":"/data-tutorial#practical-objective-of-the-tutorial","position":5},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"The Data set"},"type":"lvl2","url":"/data-tutorial#the-data-set","position":6},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"The Data set"},"content":"The data can be downloaded \n\nhere for the french departemnt of Haute-Savoie (74). If you wish to use a different area, you can find more data \n\nhere.\n\nThe data set is organized as follows:\n\nthe description file : Q_descriptif_champs_RR-T-Vent.csv\n\nthe data from 1950 to 2024 : Q_74_previous-1950-2024_RR-T-Vent.csv\n\nthe data from 1876 to 1950 : Q_74_1876-1949_RR-T-Vent.csv\n\nThe description file gives folowig information about the data columns:\n`\n\nNUM_POSTE   : numéro Météo-France du poste sur 8 chiffres\n\nNOM_USUEL   : nom usuel du poste\n\nLAT         : latitude, négative au sud (en degrés et millionièmes de degré)\n\nLON         : longitude, négative à l’ouest de GREENWICH (en degrés et millionièmes de degré)\n\nALTI        : altitude du pied de l’abri ou du pluviomètre si pas d’abri (en m)\n\nAAAAMMJJ    : date de la mesure (année mois jour)\n\nRR          : quantité de précipitation tombée en 24 heures (de 06h FU le jour J à 06h FU le jour J+1). La valeur relevée à J+1 est affectée au jour J (en mm et 1/10)\n\nTN          : température minimale sous abri (en °C et 1/10)\n\nHTN         : heure de TN (hhmm)\n\nTX         : température maximale sous abri (en °C et 1/10)\n\nHTX         : heure de TX (hhmm)\n\nTM          : moyenne quotidienne des températures horaires sous abri (en °C et 1/10)\n\nTNTXM       : moyenne quotidienne (TN+TX)/2 (en °C et 1/10)\n\nTAMPLI      : amplitude thermique quotidienne : écart entre TX et TN quotidiens (TX-TN) (en °C et 1/10)\n\nTNSOL       : température quotidienne minimale à 10 cm au-dessus du sol (en °C et 1/10)\n\nTN50        : température quotidienne minimale à 50 cm au-dessus du sol (en °C et 1/10)\n\nDG          : durée de gel sous abri (T ≤ 0°C) (en mn)\n\nFFM         : moyenne quotidienne de la force du vent moyenné sur 10 mn, à 10 m (en m/s et 1/10)\n\nFF2M        : moyenne quotidienne de la force du vent moyenné sur 10 mn, à 2 m (en m/s et 1/10)\n\nFXY         : maximum quotidien de la force maximale horaire du vent moyenné sur 10 mn, à 10 m (en m/s et 1/10)\n\nDXY         : direction de FXY (en rose de 360)\n\nHXY         : heure de FXY (hhmm)\n\nFXI         : maximum quotidien de la force maximale horaire du vent instantané, à 10 m (en m/s et 1/10)\n\nDXI         : direction de FXI (en rose de 360)\n\nHXI         : heure de FXI (hhmm)\n\nFXI2        : maximum quotidien de la force maximale horaire du vent instantané, à 2 m (en m/s et 1/10)\n\nDXI2        : direction de FXI2 (en rose de 360)\n\nHXI2        : heure de FXI2 (hhmm)\n\nFXI3S       : maximum quotidien de la force maximale horaire du vent moyenné sur 3 s, à 10 m (en m/s et 1/10)\n\nDXI3S       : direction de FXI3S (en rose de 360)\n\nHXI3S       : heure de FXI3S (hhmm)\n\nDRR         : durée des précipitations (en mn)\n`\n\n# Setup\n%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib import animation, rc, cm\n\nrc(\"animation\", html=\"html5\")\n\n\n\n","type":"content","url":"/data-tutorial#the-data-set","position":7},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Questions"},"type":"lvl2","url":"/data-tutorial#questions","position":8},{"hierarchy":{"lvl1":"Analysis of data from a weather station","lvl2":"Questions"},"content":"\n\nQuestion:\n\nWhat is the file format of the data provided?\n\nWhich program can you open it with?\n\nWhat is the size of the data file?\n\nhow many records (rows) does it contain?\n\nidentify a station that we would like to analyse.\n\nYou can use one of the following satation :\n\n74001001\tABONDANCE\n\n74056001\tCHAMONIX\n\n74024001\tAYZE\n\n74203001\tNOVEL\n\n74280001\tTHONES\n\n74281001\tTHONON-INRAE\n\n74256001\tSALLANCHES\n\n74134002\tGETS (LES)\n\n74173001\tMEGEVE\n\n74087001\tCONTAMINE-SUR- ARVE\n\n74085001\tCONTAMINES MJ\n\nQuestion: Load the data base with pandasand observe the different fields.\n\n\n\n\n\nQuestion: Select de data for the station you identified before.\n\n\n\n\n\nQuestion: Remove unnecessary columns, keep only the date and the temperature fields (TX, TM, TN).\n\n\n\n\n\nQuestion: How the date is formatted? Use the pandas function to_datetime() to convert it to date type data.\n\n\n\n\n\nQuestion: Plot the temperature vs time for the selected station.\n\n\n\n\n\nQuestion: Compute the annual average of each temperature (TN, TX)? And plot it.\n\nThe date object allows to acces date informations.\nIf D is a DATE object :\n\nD.dt.year gives the year of the date\n\nD.dt.month gives the month of the date\n\n\n\n\n\nQuestion: Compute the average temperature on the preindustrial period 1950-1980 and plot it as a horizontal line on the previous plot.\n\n\n\n\n\nQuestion: Calculates the gap between this reference temperature and the following years (1980 to 2024).\n\n\n\n\n\nQuestion: Make a plot looking like the warming stripes plot shown above.\n\n\n\n\n\n# a look like warmping stripes plot that you can use\nT_dummy = np.random.rand(100)\nfig, ax = plt.subplots()\nplt.imshow([T_dummy], aspect=\"auto\", cmap=cm.bwr)\n# set axis off\nax.axis(\"off\")\nplt.show()\n\n\n\nQuestion: using the extra data set Q_74_1876-1949_RR-T-Vent.csv extend the analysis back to 1876.","type":"content","url":"/data-tutorial#questions","position":9},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises-2","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"In this section, we propose quick exercises that can typically be done in an hour and a half:\n\nAnalysis of data from a weather station (Duration 1.5 h): Load, read, analyze and plot climate data from an Alpes weather station.\n\nTensile test analysis (Duration 4 h) : Learn to analyze tensile data (force and displacement measurements).\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/exercises-2","position":1},{"hierarchy":{"lvl1":"Word Generator"},"type":"lvl1","url":"/word-generator","position":0},{"hierarchy":{"lvl1":"Word Generator"},"content":"","type":"content","url":"/word-generator","position":1},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Scope"},"type":"lvl2","url":"/word-generator#scope","position":2},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Scope"},"content":"This notebook was inspired by the great video proposed by David Louapre available on his Youtube channel “Science Etonnante”.\n\nhttps://​sciencetonnante​.wordpress​.com​/2015​/11​/06​/la​-machine​-a​-inventer​-des​-mots​-version​-ikea/\n\nHere the word generator is embedded in a class.\n\n# Setup\n%load_ext autoreload\n%matplotlib ipympl\n%autoreload 2\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport IPython, io, urllib\nimport codecs\nimport re\nfrom numpy.random import choice, seed\n\nseed(1)\n\n\n\n","type":"content","url":"/word-generator#scope","position":3},{"hierarchy":{"lvl1":"Word Generator","lvl2":"The video"},"type":"lvl2","url":"/word-generator#the-video","position":4},{"hierarchy":{"lvl1":"Word Generator","lvl2":"The video"},"content":"\n\nIPython.display.YouTubeVideo(\"YsR7r2378j0\")\n\n\n\n","type":"content","url":"/word-generator#the-video","position":5},{"hierarchy":{"lvl1":"Word Generator","lvl2":"The Class that manage the word generator"},"type":"lvl2","url":"/word-generator#the-class-that-manage-the-word-generator","position":6},{"hierarchy":{"lvl1":"Word Generator","lvl2":"The Class that manage the word generator"},"content":"\n\nclass word_generator:\n    def __init__(self, dic_file):\n        # Input file containing one word per line, and its encoding\n        # Assumes one word per line but if the the words are followed by\n        # a space, a tab, a slash, a comma, etc....the end of the line will be trimmed\n        self.dic_file = dic_file\n        self.encoding = \"ISO-8859-1\"\n\n        # Name of the output binary matrix, matrix image file and output txt file\n        count_file = r\"count_FR.bin\"\n        proba_matrix = r\"matrix_FR.png\"\n        self.outfile = r\"output.txt\"\n\n        self.read_dic()\n\n    def read_dic(self):\n        self.dico = []  # to store the words of the dictionnary\n\n        self.count = np.zeros((256, 256, 256), dtype=\"int32\")\n        with codecs.open(self.dic_file, \"r\", self.encoding) as lines:\n            for l in lines:\n                # Trimming of the line :\n                # Split on white space, tab, slash backslah or open parenthesis\n                # and keep the first string, add EOL character\n                l2 = re.split(\"[ /\\\\\\t,\\(]\", l)[0] + \"\\n\"\n                self.dico.append(l2[:-1])\n                i, j = 0, 0\n                for k in [ord(c) for c in list(l2)]:\n                    self.count[i, j, k] += 1\n                    i = j\n                    j = k\n\n    def plot(self):\n        count2D = self.count.sum(axis=0)\n        p2D = count2D.astype(\"float\") / np.tile(sum(count2D.T), (256, 1)).T\n        p2D[np.isnan(p2D)] = 0\n\n        # For better contrast, we plot p^alpha instead of p\n        alpha = 0.33\n        p2Da = p2D**alpha\n        self.p2Da = p2Da[97:123, 97:123]\n\n        # We display only letters a to z, ie ASCII from 97 to 123.\n        plt.figure(figsize=(8, 8))\n        gr = plt.imshow(self.p2Da, interpolation=\"nearest\", cmap=mpl.cm.OrRd)\n        plt.axis(\"off\")\n        cbar = plt.colorbar(gr, orientation=\"vertical\")\n\n        for i in range(97, 123):\n            plt.text(\n                -1,\n                i - 97,\n                chr(i),\n                horizontalalignment=\"center\",\n                verticalalignment=\"center\",\n            )\n            plt.text(\n                i - 97,\n                -1,\n                chr(i),\n                horizontalalignment=\"center\",\n                verticalalignment=\"center\",\n            )\n\n    def __call__(self):\n        # For the random generator : what is the minimum and maximum number of letters\n        # in the words that we want to generate, and how many words for each length\n        smin, smax = 4, 12\n        K = 5\n\n        # Compute the probabilities by normalizing the counts\n        s = self.count.sum(axis=2)\n        st = np.tile(s.T, (256, 1, 1)).T\n        p = self.count.astype(\"float\") / st\n        p[np.isnan(p)] = 0\n\n        f = codecs.open(self.outfile, \"w\", self.encoding)\n        # Generate words\n        for size in range(smin, smax + 1):\n            total = 0\n            while total < K:\n                i, j = 0, 0\n                res = \"\"\n                while not j == 10:\n                    k = choice(range(256), 1, p=p[i, j, :])[0]\n                    res = res + chr(k)\n                    i, j = j, k\n                if len(res) == 1 + size:\n                    x = res[:-1]\n                    if res[:-1] in self.dico:\n                        x = res[:-1] + \"*\"\n                    total += 1\n                    print(x)\n                    f.write(x + \"\\n\")\n        f.close()\n\n\n\n","type":"content","url":"/word-generator#the-class-that-manage-the-word-generator","position":7},{"hierarchy":{"lvl1":"Word Generator","lvl2":"French"},"type":"lvl2","url":"/word-generator#french","position":8},{"hierarchy":{"lvl1":"Word Generator","lvl2":"French"},"content":"\n\ngen_FR = word_generator(r\"_DATA/dic/FR_aisi.txt\")\ngen_FR.plot()\nplt.show()\n\n\n\n\n\ngen_FR()\n\n\n\n","type":"content","url":"/word-generator#french","position":9},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Swedish"},"type":"lvl2","url":"/word-generator#swedish","position":10},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Swedish"},"content":"\n\ngen_SE = word_generator(r\"_DATA/dic/SE_aisi.txt\")\ngen_SE.plot()\n\n\n\ngen_SE()\n\n\n\n","type":"content","url":"/word-generator#swedish","position":11},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Compare french and swedisch"},"type":"lvl2","url":"/word-generator#compare-french-and-swedisch","position":12},{"hierarchy":{"lvl1":"Word Generator","lvl2":"Compare french and swedisch"},"content":"\n\nfig = plt.figure()\nax = fig.add_subplot(1, 2, 1)\nax.imshow(gen_FR.p2Da, interpolation=\"nearest\", cmap=mpl.cm.OrRd)\nax.axis(\"off\")\nfor i in range(97, 123):\n    plt.text(\n        -1, i - 97, chr(i), horizontalalignment=\"center\", verticalalignment=\"center\"\n    )\n    plt.text(\n        i - 97, -1, chr(i), horizontalalignment=\"center\", verticalalignment=\"center\"\n    )\nplt.title(\"French\")\n\nax = fig.add_subplot(1, 2, 2)\nax.imshow(gen_SE.p2Da, interpolation=\"nearest\", cmap=mpl.cm.OrRd)\nax.axis(\"off\")\nfor i in range(97, 123):\n    plt.text(\n        -1, i - 97, chr(i), horizontalalignment=\"center\", verticalalignment=\"center\"\n    )\n    plt.text(\n        i - 97, -1, chr(i), horizontalalignment=\"center\", verticalalignment=\"center\"\n    )\nplt.title(\"Swedisch\")\nplt.show()\n\n","type":"content","url":"/word-generator#compare-french-and-swedisch","position":13},{"hierarchy":{"lvl1":"Ressources"},"type":"lvl1","url":"/ressources","position":0},{"hierarchy":{"lvl1":"Ressources"},"content":"The section regroups several examples :\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/ressources","position":1},{"hierarchy":{"lvl1":"Linear regression - Linear model"},"type":"lvl1","url":"/linear-regression-linear-model","position":0},{"hierarchy":{"lvl1":"Linear regression - Linear model"},"content":"Linear regression is a fundamental technique in data science used to model the relationship between a dependent variable and one or more independent variables.\nIt is widely used for predictive analysis, trend forecasting, and determining the strength of predictors.\nBy fitting a linear equation to observed data, linear regression helps in understanding how the dependent variable changes with variations in the independent variables, making it a powerful tool for both explanatory and predictive modeling.\n\n","type":"content","url":"/linear-regression-linear-model","position":1},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Scope"},"type":"lvl2","url":"/linear-regression-linear-model#scope","position":2},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Scope"},"content":"A finite number N of data points are available: find the best line going trought this N points.\n\nLinear regression\n\n# setup\n%matplotlib ipympl\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport ipywidgets as ipw\n\n\n\n","type":"content","url":"/linear-regression-linear-model#scope","position":3},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Introduction with a simple tow points line equation"},"type":"lvl2","url":"/linear-regression-linear-model#introduction-with-a-simple-tow-points-line-equation","position":4},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Introduction with a simple tow points line equation"},"content":"\n\nLet’s annalyse how to determine the simple equation of a linear function (y=ax+b) kowing tow points of the line.\n\n# the known points\ny = np.array([-1, 2])\nx = np.array([0.5, 3])\nx, y\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\")\nplt.grid()\n\n\n\nTo dertermine the a and b coefficents, we have to solve the following system:y_0=ax_0+by_1=ax_1+b\n\nLets reorgenized a bit this system:b + ax_0 = y_0b + ax_1 = y_1\n\nIts now easy to write it as a linear system:\\begin{bmatrix} \n1 & x_0 \\\\\n1 & x_1 \n\\end{bmatrix}\n.\n\\begin{bmatrix} \nb \\\\\na\n\\end{bmatrix}\n=\n\\begin{bmatrix} \ny_0 \\\\\ny_1\n\\end{bmatrix}\n\nTherfore the a and b coefficents can be determine by inversing the linear system:\\begin{bmatrix} \nb \\\\\na\n\\end{bmatrix}\n=\n\\begin{bmatrix} \n1 & x_0 \\\\\n1 & x_1 \n\\end{bmatrix}^{-1}\n.\n\\begin{bmatrix} \ny_0 \\\\\ny_1\n\\end{bmatrix}\n\n","type":"content","url":"/linear-regression-linear-model#introduction-with-a-simple-tow-points-line-equation","position":5},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s do this with python","lvl2":"Introduction with a simple tow points line equation"},"type":"lvl3","url":"/linear-regression-linear-model#lets-do-this-with-python","position":6},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s do this with python","lvl2":"Introduction with a simple tow points line equation"},"content":"\n\n# definition of the involved matrix :\nX = np.array([[1, x[0]], [1, x[1]]])\nprint(\"X=\", X)\nY = np.array([y[0], y[1]]).T\nprint(\"Y=\", Y)\n\n\n\n# Inversion of the systeme\ncoef = np.dot(np.linalg.inv(X), Y)\na = coef[1]\nb = coef[0]\nprint(\n    \"a=\",\n    a,\n)\nprint(\"b=\", b)\n\n\n\n# draw the obtained line\nN = 10\nxmin, xmax = 0.0, 4\nxi = np.linspace(xmin, xmax, N)\nyi = a * xi + b\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\")\nplt.plot(xi, yi, \"r\")\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-linear-model#lets-do-this-with-python","position":7},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"What append if we add a third point ?"},"type":"lvl2","url":"/linear-regression-linear-model#what-append-if-we-add-a-third-point","position":8},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"What append if we add a third point ?"},"content":"\n\n# the known points\ny = np.array([-1, 2, 0])\nx = np.array([0.5, 3, 1.5])\nx, y\n\n\n\nTo dertermine the a and b coefficents, we have to solve the following system:y_0=ax_0+by_1=ax_1+by_2=ax_2+b\n\nThis system is over deffined: we have 2 unkowns (a,b) and 3 equations.\n\nThe goal is now to find the a and b coefficients (i.e. to find the linear equation) that fit the best the given data.\n\nWe can rewrite the equations in the form of the following linear system:\\begin{bmatrix} \n1 & x_0 \\\\\n1 & x_1 \\\\\n1 & x_2\n\\end{bmatrix}\n\\begin{bmatrix} \nb \\\\\na\n\\end{bmatrix}\n=\n\\begin{bmatrix} \ny_0 \\\\\ny_1 \\\\\ny_2\n\\end{bmatrix}\n\nThe system can be express in a genral form:X \\beta=Y\n\nThe matrix X is not square, and therfore not inversible. The methode presented above is no more apllicable.\n\nThe trick is to multiply the system by the transposed of X.X^t X \\beta= X^t Y\n\nThe therm X^t X is now a square matrix.\n\n","type":"content","url":"/linear-regression-linear-model#what-append-if-we-add-a-third-point","position":9},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s check this affirmation:","lvl2":"What append if we add a third point ?"},"type":"lvl3","url":"/linear-regression-linear-model#lets-check-this-affirmation","position":10},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s check this affirmation:","lvl2":"What append if we add a third point ?"},"content":"\n\n# Construcion of the X matrix\nX = np.array([np.ones(x.size), x]).T\nX\n\n\n\n# Computation of Xt X\nnp.dot(X.T, X)\n\n\n\nThe obtained matrix is a square matrix and it can proved that this matrix is symmetric, and therfore always inversible.\n\nFrom the previous equation:X^t X \\beta= X^t Y\n\nThe \\beta vector can be express by as :\\beta= \\left( X^t X \\right)^{-1} X^t Y\n\nThis operator is the least square estimator.\n\n","type":"content","url":"/linear-regression-linear-model#lets-check-this-affirmation","position":11},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s do this with python","lvl2":"What append if we add a third point ?"},"type":"lvl3","url":"/linear-regression-linear-model#lets-do-this-with-python-1","position":12},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Let’s do this with python","lvl2":"What append if we add a third point ?"},"content":"\n\n# Construcion of the X matrix\nX = np.array([np.ones(x.size), x]).T\n\n# Construcion of the Y matrix\nY = y.T\n\nprint(\"X=\", X)\n\nprint(\"Y=\", Y)\n\n\n\n# Computation of the least square estimator\nbeta = np.dot(np.linalg.inv(np.dot(X.T, X)), np.dot(X.T, Y))\nprint(\"beta=\", beta)\n\nprint(\"The fitted linear function is:\")\nprint(\"y=\", beta[1], \"x +\", beta[0])\n\n\n\n","type":"content","url":"/linear-regression-linear-model#lets-do-this-with-python-1","position":13},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Now its time to plot the line","lvl2":"What append if we add a third point ?"},"type":"lvl3","url":"/linear-regression-linear-model#now-its-time-to-plot-the-line","position":14},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Now its time to plot the line","lvl2":"What append if we add a third point ?"},"content":"\n\n# draw the obtained line\nN = 10\nxmin, xmax = 0.0, 4\nxi = np.linspace(xmin, xmax, N)\nyi = beta[0] + beta[1] * xi\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\")\nplt.plot(xi, yi, \"r\")\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-linear-model#now-its-time-to-plot-the-line","position":15},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"With a larger data set ?"},"type":"lvl2","url":"/linear-regression-linear-model#with-a-larger-data-set","position":16},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"With a larger data set ?"},"content":"\n\n","type":"content","url":"/linear-regression-linear-model#with-a-larger-data-set","position":17},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"The data set : a synthetique data set with some noise","lvl2":"With a larger data set ?"},"type":"lvl3","url":"/linear-regression-linear-model#the-data-set-a-synthetique-data-set-with-some-noise","position":18},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"The data set : a synthetique data set with some noise","lvl2":"With a larger data set ?"},"content":"\n\nN = 100\nxmin, xmax = 0.0, 4\nx = np.linspace(xmin, xmax, N) + np.random.rand(N)\ny = (3.3 * x - 2) + 2 * np.random.randn(N)\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\", label=\"Data\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-linear-model#the-data-set-a-synthetique-data-set-with-some-noise","position":19},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Determination of the coefficent by regression","lvl2":"With a larger data set ?"},"type":"lvl3","url":"/linear-regression-linear-model#determination-of-the-coefficent-by-regression","position":20},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Determination of the coefficent by regression","lvl2":"With a larger data set ?"},"content":"\n\n# Construcion of the X matrix\nX = np.array([np.ones(x.size), x]).T\n\n# Construcion of the Y matrix\nY = y.T\n\n# Computation of the least square estimator\nbeta = np.dot(np.linalg.inv(np.dot(X.T, X)), np.dot(X.T, Y))\n\nprint(\"The fitted linear function is:\")\nprint(\"y=\", beta[1], \"x +\", beta[0])\n\n\n\n","type":"content","url":"/linear-regression-linear-model#determination-of-the-coefficent-by-regression","position":21},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Draw the obtain regression line","lvl2":"With a larger data set ?"},"type":"lvl3","url":"/linear-regression-linear-model#draw-the-obtain-regression-line","position":22},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Draw the obtain regression line","lvl2":"With a larger data set ?"},"content":"\n\nN = 10\nxmin, xmax = 0.0, 5\nxi = np.linspace(xmin, xmax, N)\nyi = beta[0] + beta[1] * xi\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\", label=\"Data\")\nplt.plot(xi, yi, \"r\", label=\"Regression\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-linear-model#draw-the-obtain-regression-line","position":23},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl2","url":"/linear-regression-linear-model#does-python-know-how-to-do-that-in-one-line","position":24},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl2":"Does python  know how to do that in one line ?"},"content":"\n\n","type":"content","url":"/linear-regression-linear-model#does-python-know-how-to-do-that-in-one-line","position":25},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Of course yes !","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl3","url":"/linear-regression-linear-model#of-course-yes","position":26},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Of course yes !","lvl2":"Does python  know how to do that in one line ?"},"content":"","type":"content","url":"/linear-regression-linear-model#of-course-yes","position":27},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Using the polyfit function of numpy:","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl3","url":"/linear-regression-linear-model#using-the-polyfit-function-of-numpy","position":28},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Using the polyfit function of numpy:","lvl2":"Does python  know how to do that in one line ?"},"content":"\n\n# compute the coefficient using the least square methode\nbeta = np.polyfit(x, y, 1)\nprint(\"beta=\", beta)\n\n# creat the associate 1d polynomila function\nfit = np.poly1d(beta)\n\n\n\n","type":"content","url":"/linear-regression-linear-model#using-the-polyfit-function-of-numpy","position":29},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Draw the obtaine regression line","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl3","url":"/linear-regression-linear-model#draw-the-obtaine-regression-line","position":30},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Draw the obtaine regression line","lvl2":"Does python  know how to do that in one line ?"},"content":"\n\nN = 10\nxmin, xmax = 0.0, 5\nxi = np.linspace(xmin, xmax, N)\nyi_numpy = fit(xi)\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\", label=\"Data\")\nplt.plot(xi, yi, \"+r\", label=\"Regression\")\nplt.plot(xi, yi_numpy, \"g\", label=\"Regression Numpy\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-linear-model#draw-the-obtaine-regression-line","position":31},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Using numpy linalg function:","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl3","url":"/linear-regression-linear-model#using-numpy-linalg-function","position":32},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"Using numpy linalg function:","lvl2":"Does python  know how to do that in one line ?"},"content":"For this methode de X ans Y matrix must be given by the user.\n\nbeta, r, rank, s = np.linalg.lstsq(X, Y, rcond=None)\nprint(\"beta=\", beta)\n\n\n\nLucky us, all methodes give the same results !\n\n","type":"content","url":"/linear-regression-linear-model#using-numpy-linalg-function","position":33},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"What is the effect of noise on the resulting regression ?","lvl2":"Does python  know how to do that in one line ?"},"type":"lvl3","url":"/linear-regression-linear-model#what-is-the-effect-of-noise-on-the-resulting-regression","position":34},{"hierarchy":{"lvl1":"Linear regression - Linear model","lvl3":"What is the effect of noise on the resulting regression ?","lvl2":"Does python  know how to do that in one line ?"},"content":"\n\nN = 100\nxmin, xmax = 0.0, 4\n\n\ndef get_data(N, sigma):\n    x = np.linspace(xmin, xmax, N)\n    y = (3.3 * x - 2) + sigma * np.random.randn(N)\n    return x, y\n\n\ndef compute_reg(x, y):\n    beta, residuals, rank, singular_values, rcond = np.polyfit(x, y, 1, full=True)\n    fit = np.poly1d(beta)\n    SStot = ((y - y.mean()) ** 2).sum()\n    SSres = residuals[0]\n    R2 = 1 - SSres / SStot\n    return beta, fit([xmin, xmax]), R2\n\n\nx, y = get_data(100, 0.0)\nbeta, fity, R2 = compute_reg(x, y)\nfig = plt.figure()\n(points_plot,) = plt.plot(x, y, \"o\", label=\"Data\")\n(line,) = plt.plot([xmin, xmax], fity, \"-r\", label=\"Regression\")\nplt.plot([xmin, xmax], fity, \"-g\", label=\"Non Noisy data\")\nplt.grid()\nplt.legend()\n\n\n@ipw.interact(N=(5, 100, 10), sigma=(0.0, 2.0, 0.1))\ndef update(N, sigma):\n    x, y = get_data(N, sigma)\n    beta, fity, R2 = compute_reg(x, y)\n    points_plot.set_xdata(x)\n    points_plot.set_ydata(y)\n    line.set_ydata(fity)\n    plt.title(\"$R^2$={:0.2f}\".format(R2))\n\n\n\n\n\nNote\n\nTo go further the reader can read the \n\nadvanced linear regression notebook.","type":"content","url":"/linear-regression-linear-model#what-is-the-effect-of-noise-on-the-resulting-regression","position":35},{"hierarchy":{"lvl1":"Linear regression - Advanced model"},"type":"lvl1","url":"/linear-regression-advanced-model","position":0},{"hierarchy":{"lvl1":"Linear regression - Advanced model"},"content":"Note\n\nthis notebook folows the \n\nlinear regression basics notebook.\n\n","type":"content","url":"/linear-regression-advanced-model","position":1},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Scope"},"type":"lvl2","url":"/linear-regression-advanced-model#scope","position":2},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Scope"},"content":"A finite number N of data points are available: find the best fit of a given parametrique function going trouth this N points.\n\n# setup\n%load_ext autoreload\n%matplotlib ipympl\n%autoreload 2\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#scope","position":3},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"The data set : a synthetique data set with some noise"},"type":"lvl2","url":"/linear-regression-advanced-model#the-data-set-a-synthetique-data-set-with-some-noise","position":4},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"The data set : a synthetique data set with some noise"},"content":"\n\nNb_data_point = 200  # number of points\nxmin, xmax = -0.5, 5.5  # x range\n\nx = np.linspace(xmin, xmax, Nb_data_point)\nx = x + 0.2 * np.random.rand(Nb_data_point)  # add noise\n\ny = x**4 - 12 * x**3 + 47 * x**2 - 60 * x\ny = y + 1 * np.random.randn(Nb_data_point)  # add noise\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \".\", label=\"Data\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#the-data-set-a-synthetique-data-set-with-some-noise","position":5},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"We would like to fit this data with a linear piecewise function"},"type":"lvl2","url":"/linear-regression-advanced-model#we-would-like-to-fit-this-data-with-a-linear-piecewise-function","position":6},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"We would like to fit this data with a linear piecewise function"},"content":"\n\nTo do so we need first a base, let’s use linear piecewise function function use in the FE methode\n\ndef hat(x, xc, support=1):\n    \"\"\"\n    Compute the hat function, which is a piecewise linear function that peaks at `xc` and\n    decreases linearly to zero within the given `support`.\n\n    Parameters:\n    x (array-like): Input array of values.\n    xc (float): Center of the peak.\n    support (float, optional): Width of the support region. Default is 1.\n\n    Returns:\n    numpy.ndarray: Array of the same shape as `x`, containing the computed hat function values.\n    \"\"\"\n\n    y = np.maximum(1 - np.abs((x - xc) / support), 0.0)\n    return y\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#we-would-like-to-fit-this-data-with-a-linear-piecewise-function","position":7},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Bases function settings","lvl2":"We would like to fit this data with a linear piecewise function"},"type":"lvl3","url":"/linear-regression-advanced-model#bases-function-settings","position":8},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Bases function settings","lvl2":"We would like to fit this data with a linear piecewise function"},"content":"\n\nNf = 9  # number of bases function\n\nxc_list = np.linspace(xmin, xmax, Nf)\nxc_list.shape\nsupport = (xmax - xmin) / (Nf - 1)\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#bases-function-settings","position":9},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the hat functions","lvl2":"We would like to fit this data with a linear piecewise function"},"type":"lvl3","url":"/linear-regression-advanced-model#draw-the-hat-functions","position":10},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the hat functions","lvl2":"We would like to fit this data with a linear piecewise function"},"content":"\n\nN = 1000\nx_hat = np.linspace(xmin, xmax, N)\n\n\n\nfig = plt.figure()\nfor i in range(0, len(xc_list)):\n    plt.plot(x_hat, hat(x_hat, xc_list[i], support))\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#draw-the-hat-functions","position":11},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Fit the data using this base of functions"},"type":"lvl2","url":"/linear-regression-advanced-model#fit-the-data-using-this-base-of-functions","position":12},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Fit the data using this base of functions"},"content":"\n\n","type":"content","url":"/linear-regression-advanced-model#fit-the-data-using-this-base-of-functions","position":13},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Determination of the coefficent by regression","lvl2":"Fit the data using this base of functions"},"type":"lvl3","url":"/linear-regression-advanced-model#determination-of-the-coefficent-by-regression","position":14},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Determination of the coefficent by regression","lvl2":"Fit the data using this base of functions"},"content":"\n\n# Construcion of the X matrix\nX = np.zeros((Nf, len(x)))\nfor i in range(0, len(xc_list)):\n    X[i, :] = hat(x, xc_list[i], support)\n    # X = np.append(X, [hat(x, xc_list[i], support)], axis=0)\nX = X.T\n\n# Construcion of the Y matrix\nY = y.T\n\n# Computation of the least square estimator\nbeta = np.dot(np.linalg.inv(np.dot(X.T, X)), np.dot(X.T, Y))\n\nprint(\"The fitted coeff:\")\nprint(beta)\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#determination-of-the-coefficent-by-regression","position":15},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the results","lvl2":"Fit the data using this base of functions"},"type":"lvl3","url":"/linear-regression-advanced-model#draw-the-results","position":16},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the results","lvl2":"Fit the data using this base of functions"},"content":"\n\nN = 100\nxi = np.linspace(xmin, xmax, N)\n\nyi = np.zeros(xi.shape)\nfor i in range(0, len(xc_list)):\n    yi = yi + beta[i] * hat(xi, xc_list[i], support)\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\", label=\"Data\")\nplt.plot(xi, yi, \"r\", label=\"Regression\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#draw-the-results","position":17},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Work with other bases"},"type":"lvl2","url":"/linear-regression-advanced-model#work-with-other-bases","position":18},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl2":"Work with other bases"},"content":"The Radial basis function (RBF) is a good candidate to fit the data.\nIt will creat a smooth curve that will fit the data, but due to the non finite support of the RBF function, the matrix to invert will be ill conditionned.\n\nThe gaussian RBF is defined as follow:\\phi(x) = \\exp\\left(-\\left(\\frac{x-x_c}{lc}\\right)^2\\right)\n\ndef hat(x, xc, support=1):\n    ### RBF\n    y = np.exp(-((np.abs(x - xc) / support) ** 2))\n    return y\n\n\n\nfig = plt.figure()\nfor i in range(0, len(xc_list)):\n    plt.plot(x_hat, hat(x_hat, xc_list[i], support))\nplt.grid()\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#work-with-other-bases","position":19},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Fit the data using this base of functions","lvl2":"Work with other bases"},"type":"lvl3","url":"/linear-regression-advanced-model#fit-the-data-using-this-base-of-functions-1","position":20},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Fit the data using this base of functions","lvl2":"Work with other bases"},"content":"\n\n# Construcion of the X matrix\nX = np.zeros((Nf, len(x)))\nfor i in range(0, len(xc_list)):\n    X[i, :] = hat(x, xc_list[i], support)\nX = X.T\n\n# Construcion of the Y matrix\nY = y.T\n\n# Computation of the least square estimator\nbeta = np.dot(np.linalg.inv(np.dot(X.T, X)), np.dot(X.T, Y))\n\nprint(\"The fitted coeff:\")\nprint(beta)\n\n\n\n","type":"content","url":"/linear-regression-advanced-model#fit-the-data-using-this-base-of-functions-1","position":21},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the results","lvl2":"Work with other bases"},"type":"lvl3","url":"/linear-regression-advanced-model#draw-the-results-1","position":22},{"hierarchy":{"lvl1":"Linear regression - Advanced model","lvl3":"Draw the results","lvl2":"Work with other bases"},"content":"\n\nN = 100\nxi = np.linspace(xmin, xmax, N)\n\nyi = np.zeros(xi.shape)\nfor i in range(0, len(xc_list)):\n    yi = yi + beta[i] * hat(xi, xc_list[i], support)\n\n\n\nfig = plt.figure()\nplt.plot(x, y, \"o\", label=\"Data\")\nplt.plot(xi, yi, \"r\", label=\"Regression\")\nplt.legend()\nplt.grid()\n\n","type":"content","url":"/linear-regression-advanced-model#draw-the-results-1","position":23},{"hierarchy":{"lvl1":"Derivation of numerical data"},"type":"lvl1","url":"/numerical-derivation","position":0},{"hierarchy":{"lvl1":"Derivation of numerical data"},"content":"","type":"content","url":"/numerical-derivation","position":1},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Scope"},"type":"lvl2","url":"/numerical-derivation#scope","position":2},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Scope"},"content":"A finite number N of data points (x,y) are available, it describes an underling function f(x).\nThe goal is to compute the derivative \\dfrac{df}{dx}\n\nNumerical differentiation is a crucial tool in various fields such as physics, engineering, and finance. It allows us to estimate the rate of change of a function based on discrete data points, which is essential for understanding trends, optimizing processes, and making predictions.\n\nNumerical differentiation\n\n# setup\n%matplotlib ipympl\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n\n\n","type":"content","url":"/numerical-derivation#scope","position":3},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Create synthetic data"},"type":"lvl2","url":"/numerical-derivation#create-synthetic-data","position":4},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Create synthetic data"},"content":"For this notebook we use data coming from a known function. In this way, we can check the accuracy of the results.\n\nthe underlying function :\n\n# The function\ndef f(x):\n    return x**2 - 3 * x + 2 * np.sin(5 * x)\n\n\n# The derivative\ndef df(x):\n    return 2 * x - 3 + 10 * np.cos(5 * x)\n\n\n\nPlotting the function and its derivative:\n\nN = 400\nxmin, xmax = 0.0, 4\nx = np.linspace(xmin, xmax, N)\n\n\n\nfig = plt.figure()\nplt.plot(x, f(x), \"b\", label=\"$f(x)$\")\nplt.legend()\nplt.grid()\n\n\n\nfig = plt.figure()\nplt.plot(x, df(x), \"b\", label=\"$\\dfrac{df}{dx}$\")\nplt.legend()\nplt.grid()\n\n\n\n\n\n","type":"content","url":"/numerical-derivation#create-synthetic-data","position":5},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl3":"Now we assume that only 40 points of this function are known:","lvl2":"Create synthetic data"},"type":"lvl3","url":"/numerical-derivation#now-we-assume-that-only-40-points-of-this-function-are-known","position":6},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl3":"Now we assume that only 40 points of this function are known:","lvl2":"Create synthetic data"},"content":"\n\nN = 40\nxmin, xmax = 0.0, 4\nxi = np.linspace(xmin, xmax, N)\nfi = f(xi)\n\n\n\nfig = plt.figure()\nplt.plot(xi, fi, \"o\", label=\"the discretize data $(x_i,f_i)$\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/numerical-derivation#now-we-assume-that-only-40-points-of-this-function-are-known","position":7},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The one point finite difference formula"},"type":"lvl2","url":"/numerical-derivation#the-one-point-finite-difference-formula","position":8},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The one point finite difference formula"},"content":"\\dfrac{df}{dx} = \\dfrac{f(x_{i+1})-f(x_i)}{x_{i+1}-x_i}\n\nThe numpy diff() function is a fast way to compute this formula:\n\ndf_1p = np.diff(fi) / np.diff(xi)\n\n\n\nBut becarefull the size of the resulting array is equal to n-1.\n\nfig = plt.figure()\nplt.plot(x, df(x), \"b\", label=\"Analytical derivative\")\nplt.plot(xi[:-1], df_1p, \"ro\", label=\"Finite difference derivative (1 point)\")\nplt.legend()\nplt.grid()\nplt.show()\n\n\n\n","type":"content","url":"/numerical-derivation#the-one-point-finite-difference-formula","position":9},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The 2 points finite difference formula"},"type":"lvl2","url":"/numerical-derivation#the-2-points-finite-difference-formula","position":10},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The 2 points finite difference formula"},"content":"\\dfrac{df}{dx} = \\dfrac{f(x_{i+1})-f(x_{i-1})}{x_{i+1}-x_{i-1}}\n\nSlicing method of numpy array is a good way to do such operation\n\n# Slicing exemple\na = np.linspace(0, 6, 7)\nprint(a[2:])\nprint(a[:-2])\n\n\n\nWith slicing methode of numpy array the 2 points formula can be fast computed:\n\ndf_2p = (fi[2:] - fi[:-2]) / (xi[2:] - xi[:-2])\n\n\n\nfig = plt.figure()\nplt.plot(x, df(x), \"b\", label=\"Analytical derivative\")\nplt.plot(xi[:-1], df_1p, \"ro\", label=\"Finite difference derivative (1 point)\")\nplt.plot(xi[1:-1], df_2p, \"gs\", label=\"Finite difference derivative (2 points)\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/numerical-derivation#the-2-points-finite-difference-formula","position":11},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Let’s have a look at the error on the derivative computation"},"type":"lvl2","url":"/numerical-derivation#lets-have-a-look-at-the-error-on-the-derivative-computation","position":12},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"Let’s have a look at the error on the derivative computation"},"content":"\n\nfig = plt.figure()\nplt.plot(\n    xi[:-1], (df_1p - df(xi[:-1])), \"ro\", label=\"Finite difference derivative (1 point)\"\n)\nplt.plot(\n    xi[1:-1],\n    (df_2p - df(xi[1:-1])),\n    \"gs\",\n    label=\"Finite difference derivative (2 points)\",\n)\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/numerical-derivation#lets-have-a-look-at-the-error-on-the-derivative-computation","position":13},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"What append if the data are noisy ?"},"type":"lvl2","url":"/numerical-derivation#what-append-if-the-data-are-noisy","position":14},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"What append if the data are noisy ?"},"content":"\n\nfi_noise = f(xi) + 0.5 * np.random.randn(fi.size)\n\n\n\nfig = plt.figure()\nplt.plot(x, f(x), \":r\", label=\"$f(x)$\")\nplt.plot(xi, fi_noise, \"o\", label=\"noisy data\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/numerical-derivation#what-append-if-the-data-are-noisy","position":15},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl3":"The 2 points fomrula is the more accurate. Let’s use it to derivate the noisy data:","lvl2":"What append if the data are noisy ?"},"type":"lvl3","url":"/numerical-derivation#the-2-points-fomrula-is-the-more-accurate-lets-use-it-to-derivate-the-noisy-data","position":16},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl3":"The 2 points fomrula is the more accurate. Let’s use it to derivate the noisy data:","lvl2":"What append if the data are noisy ?"},"content":"\n\ndf_2p_n = (fi_noise[2:] - fi_noise[:-2]) / (xi[2:] - xi[:-2])\n\n\n\nfig = plt.figure()\nplt.plot(x, df(x), \":r\", label=\"Analytical derivative\")\nplt.plot(xi[1:-1], df_2p_n, \"-g\", label=\"Finite difference derivative of noisy data\")\nplt.legend()\nplt.grid()\n\n\n\n","type":"content","url":"/numerical-derivation#the-2-points-fomrula-is-the-more-accurate-lets-use-it-to-derivate-the-noisy-data","position":17},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The obtaine results is not valuable for further use. Other methodes should be used to evaluat derivative of noisy data."},"type":"lvl2","url":"/numerical-derivation#the-obtaine-results-is-not-valuable-for-further-use-other-methodes-should-be-used-to-evaluat-derivative-of-noisy-data","position":18},{"hierarchy":{"lvl1":"Derivation of numerical data","lvl2":"The obtaine results is not valuable for further use. Other methodes should be used to evaluat derivative of noisy data."},"content":"","type":"content","url":"/numerical-derivation#the-obtaine-results-is-not-valuable-for-further-use-other-methodes-should-be-used-to-evaluat-derivative-of-noisy-data","position":19},{"hierarchy":{"lvl1":"Introduction"},"type":"lvl1","url":"/pandas-introduction","position":0},{"hierarchy":{"lvl1":"Introduction"},"content":"","type":"content","url":"/pandas-introduction","position":1},{"hierarchy":{"lvl1":"Introduction","lvl2":"Preamble"},"type":"lvl2","url":"/pandas-introduction#preamble","position":2},{"hierarchy":{"lvl1":"Introduction","lvl2":"Preamble"},"content":"The data analysis process is a series of steps that are used to organize, clean, and analyze data.\nThe process is used to extract useful information from the data and to make decisions based on the data.\nThe process is used in a variety of fields, including business, science, and engineering.\nThe process is typically broken down into several steps, including data collection, data cleaning, data analysis, and data visualization.\n\nThe scope of this notebook is to provide a brief introduction to the data analysis process using the Python programming language and the Pandas library (\n\nhttps://​pandas​.pydata​.org/).\nPandas is a powerful data manipulation library for Python that provides data structures and functions for working with structured data.\nIt also provides basic tools for data visualization, but the use of more powerful libraries like \n\nMatplotlib or \n\nSeaborn is recommended for more complex visualizations.\n\nFor data manipulation, we make the choice to work with \n\nPandas; other libraries like \n\nNumPy, \n\nSciPy, and \n\nScikit-learn are also commonly used for data analysis.","type":"content","url":"/pandas-introduction#preamble","position":3},{"hierarchy":{"lvl1":"Introduction","lvl2":"Objectives"},"type":"lvl2","url":"/pandas-introduction#objectives","position":4},{"hierarchy":{"lvl1":"Introduction","lvl2":"Objectives"},"content":"in this notebook, we will cover the following topics:\n\nData Laoding\n\nData Manipulation\n\nData Visualization\n\nData Analysis / data modeling\n\nWe will use as example data set a list of students with their grades in different tests.\n\n# Setup\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\n\n\n\n","type":"content","url":"/pandas-introduction#objectives","position":5},{"hierarchy":{"lvl1":"Introduction","lvl2":"First of all, let’s have a look at the data set"},"type":"lvl2","url":"/pandas-introduction#first-of-all-lets-have-a-look-at-the-data-set","position":6},{"hierarchy":{"lvl1":"Introduction","lvl2":"First of all, let’s have a look at the data set"},"content":"For that you need to open the data set in is native format, in this case a csv file.\ncsv files are text files that store data in a tabular format, with each row representing a record and each column representing a field.\nTherefore, you can open the file with a text editor or a spreadsheet software like Excel.\n\nRequired files\n\nThe data set is available in the _DATA folder attached to this notebook.\n\nwarning\n\nOpen the data with Excel might change the format of the data, so it is recommended to use a text editor like Notepad++ or Visual Studio Code.\n\n","type":"content","url":"/pandas-introduction#first-of-all-lets-have-a-look-at-the-data-set","position":7},{"hierarchy":{"lvl1":"Introduction","lvl2":"Data Loading and basic manipulation"},"type":"lvl2","url":"/pandas-introduction#data-loading-and-basic-manipulation","position":8},{"hierarchy":{"lvl1":"Introduction","lvl2":"Data Loading and basic manipulation"},"content":"","type":"content","url":"/pandas-introduction#data-loading-and-basic-manipulation","position":9},{"hierarchy":{"lvl1":"Introduction","lvl3":"Load data and create a data frame from csv file","lvl2":"Data Loading and basic manipulation"},"type":"lvl3","url":"/pandas-introduction#load-data-and-create-a-data-frame-from-csv-file","position":10},{"hierarchy":{"lvl1":"Introduction","lvl3":"Load data and create a data frame from csv file","lvl2":"Data Loading and basic manipulation"},"content":"More explanation can be found here : \n\nhttps://​chrisalbon​.com​/python​/data​_wrangling​/pandas​_dataframe​_importing​_csv/\n\ndf = pd.read_csv(\"./_DATA/Note_csv.csv\", delimiter=\";\")\ndf\n\n\n\n","type":"content","url":"/pandas-introduction#load-data-and-create-a-data-frame-from-csv-file","position":11},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the dataframe","lvl2":"Data Loading and basic manipulation"},"type":"lvl3","url":"/pandas-introduction#display-the-dataframe","position":12},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the dataframe","lvl2":"Data Loading and basic manipulation"},"content":"\n\n# return the beginning of the dataframe\ndf = df.fillna(0.0)\ndf.head(10)\n\n\n\n# return the end of the dataframe\ndf.tail(10)\n\n\n\n","type":"content","url":"/pandas-introduction#display-the-dataframe","position":13},{"hierarchy":{"lvl1":"Introduction","lvl3":"Selecting data in a dataframe","lvl2":"Data Loading and basic manipulation"},"type":"lvl3","url":"/pandas-introduction#selecting-data-in-a-dataframe","position":14},{"hierarchy":{"lvl1":"Introduction","lvl3":"Selecting data in a dataframe","lvl2":"Data Loading and basic manipulation"},"content":"\n\n# get data from index 2\ndf.loc[2]\n\n\n\n# get name from index 2\ndf.name[2]\n\n\n\n# Sliccing is also working\n\ndf.name[2:6]\n\n\n\n","type":"content","url":"/pandas-introduction#selecting-data-in-a-dataframe","position":15},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get one of row of the dataframe","lvl2":"Data Loading and basic manipulation"},"type":"lvl3","url":"/pandas-introduction#get-one-of-row-of-the-dataframe","position":16},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get one of row of the dataframe","lvl2":"Data Loading and basic manipulation"},"content":"\n\ndf.TD\n\n\n\n","type":"content","url":"/pandas-introduction#get-one-of-row-of-the-dataframe","position":17},{"hierarchy":{"lvl1":"Introduction","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl2","url":"/pandas-introduction#start-to-do-some-basic-analysis-and-visualization","position":18},{"hierarchy":{"lvl1":"Introduction","lvl2":"Start to do some basic analysis and visualization"},"content":"","type":"content","url":"/pandas-introduction#start-to-do-some-basic-analysis-and-visualization","position":19},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get the number of students in each group.","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#get-the-number-of-students-in-each-group","position":20},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get the number of students in each group.","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf.TD.value_counts()\n\n\n\n","type":"content","url":"/pandas-introduction#get-the-number-of-students-in-each-group","position":21},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get the proportion of students between groups","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#get-the-proportion-of-students-between-groups","position":22},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get the proportion of students between groups","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf.TD.value_counts(normalize=True)\n\n\n\n","type":"content","url":"/pandas-introduction#get-the-proportion-of-students-between-groups","position":23},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the proportion of students between groups","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#display-the-proportion-of-students-between-groups","position":24},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the proportion of students between groups","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\nUsing the plot function of panda:\n\nvisualization option of pandas can be found here : \n\nhttp://​pandas​.pydata​.org​/pandas​-docs​/version​/0​.18​/visualization​.html\n\nfig = plt.figure()\ndf.TD.value_counts(normalize=True).plot.pie(\n    labels=[\"A\", \"B\", \"C\", \"D\"], colors=[\"r\", \"g\", \"b\", \"y\"], autopct=\"%.1f\"\n)\nplt.show()\n\n\n\nUsing the plot function of matplotlib:\n\nval = df.TD.value_counts(normalize=True).values\nexplode = (0.5, 0, 0.2, 0)\nlabels = \"A\", \"B\", \"C\", \"D\"\nfig1, ax1 = plt.subplots()\nax1.pie(\n    val, explode=explode, labels=labels, autopct=\"%1.1f%%\", shadow=True, startangle=90\n)\nax1.axis(\"equal\")  # Equal aspect ratio ensures that pie is drawn as a circle.\n\nplt.show()\n\n\n\n","type":"content","url":"/pandas-introduction#display-the-proportion-of-students-between-groups","position":25},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get student list who get a grad higher than 14/20 on both ET and CC","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#get-student-list-who-get-a-grad-higher-than-14-20-on-both-et-and-cc","position":26},{"hierarchy":{"lvl1":"Introduction","lvl3":"Get student list who get a grad higher than 14/20 on both ET and CC","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf[(df.ET > 14.0) & (df.CC > 14.0)]\n\n\n\n","type":"content","url":"/pandas-introduction#get-student-list-who-get-a-grad-higher-than-14-20-on-both-et-and-cc","position":27},{"hierarchy":{"lvl1":"Introduction","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#make-calculation-on-data","position":28},{"hierarchy":{"lvl1":"Introduction","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"content":"","type":"content","url":"/pandas-introduction#make-calculation-on-data","position":29},{"hierarchy":{"lvl1":"Introduction","lvl4":"The mean of ET grads over all students","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl4","url":"/pandas-introduction#the-mean-of-et-grads-over-all-students","position":30},{"hierarchy":{"lvl1":"Introduction","lvl4":"The mean of ET grads over all students","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf.ET.mean()\n\n\n\n","type":"content","url":"/pandas-introduction#the-mean-of-et-grads-over-all-students","position":31},{"hierarchy":{"lvl1":"Introduction","lvl4":"The mean of ET over students from B group","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl4","url":"/pandas-introduction#the-mean-of-et-over-students-from-b-group","position":32},{"hierarchy":{"lvl1":"Introduction","lvl4":"The mean of ET over students from B group","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf.ET[df.TD == \"B\"].mean()\n\n\n\n","type":"content","url":"/pandas-introduction#the-mean-of-et-over-students-from-b-group","position":33},{"hierarchy":{"lvl1":"Introduction","lvl4":"Statistical description of the data by TD using the ‘groupby()’ function","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl4","url":"/pandas-introduction#statistical-description-of-the-data-by-td-using-the-groupby-function","position":34},{"hierarchy":{"lvl1":"Introduction","lvl4":"Statistical description of the data by TD using the ‘groupby()’ function","lvl3":"Make Calculation on Data","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\ndf.groupby([\"TD\"]).describe()  # compte the mean of each note for each groupe\n\n\n\n","type":"content","url":"/pandas-introduction#statistical-description-of-the-data-by-td-using-the-groupby-function","position":35},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the grads with a histogram plot","lvl2":"Start to do some basic analysis and visualization"},"type":"lvl3","url":"/pandas-introduction#display-the-grads-with-a-histogram-plot","position":36},{"hierarchy":{"lvl1":"Introduction","lvl3":"Display the grads with a histogram plot","lvl2":"Start to do some basic analysis and visualization"},"content":"\n\n# CC notes\nfig = plt.figure()\ndf.CC.plot.hist(alpha=0.5, bins=np.arange(1, 20))\nplt.show()\n\n\n\n# ET notes\nfig = plt.figure()\ndf.ET.plot.hist(alpha=0.5, bins=np.arange(1, 20))\nplt.show()\n\n\n\nfig = plt.figure()\ndf.plot.hist(alpha=0.5, bins=np.arange(1, 20))\nplt.show()\n\n\n\n\n\n","type":"content","url":"/pandas-introduction#display-the-grads-with-a-histogram-plot","position":37},{"hierarchy":{"lvl1":"Introduction","lvl2":"Let’s compute the mean of both grads"},"type":"lvl2","url":"/pandas-introduction#lets-compute-the-mean-of-both-grads","position":38},{"hierarchy":{"lvl1":"Introduction","lvl2":"Let’s compute the mean of both grads"},"content":"\n\n","type":"content","url":"/pandas-introduction#lets-compute-the-mean-of-both-grads","position":39},{"hierarchy":{"lvl1":"Introduction","lvl3":"We need first to add a new row to a data frame","lvl2":"Let’s compute the mean of both grads"},"type":"lvl3","url":"/pandas-introduction#we-need-first-to-add-a-new-row-to-a-data-frame","position":40},{"hierarchy":{"lvl1":"Introduction","lvl3":"We need first to add a new row to a data frame","lvl2":"Let’s compute the mean of both grads"},"content":"\n\ndf[\"FinalNote\"] = 0.0  # add  row filled with 0.0\ndf\n\n\n\ndf.head()\n\n\n\n","type":"content","url":"/pandas-introduction#we-need-first-to-add-a-new-row-to-a-data-frame","position":41},{"hierarchy":{"lvl1":"Introduction","lvl3":"Let’s compute the mean","lvl2":"Let’s compute the mean of both grads"},"type":"lvl3","url":"/pandas-introduction#lets-compute-the-mean","position":42},{"hierarchy":{"lvl1":"Introduction","lvl3":"Let’s compute the mean","lvl2":"Let’s compute the mean of both grads"},"content":"\n\ndf[\"FinalNote\"] = 0.7 * df.ET + 0.3 * df.CC\n# the axis option alows comptuting the mean over lines or rows\n\n\n\ndf.head()\n\n\n\nfig = plt.figure()\ndf.FinalNote.plot.hist(alpha=0.5, bins=np.arange(1, 20))\nplt.show()\n\n\n\n","type":"content","url":"/pandas-introduction#lets-compute-the-mean","position":43},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is the overall mean ?"},"type":"lvl2","url":"/pandas-introduction#what-is-the-overall-mean","position":44},{"hierarchy":{"lvl1":"Introduction","lvl2":"What is the overall mean ?"},"content":"\n\ndf.FinalNote.mean()\n\n","type":"content","url":"/pandas-introduction#what-is-the-overall-mean","position":45},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material-1","position":0},{"hierarchy":{"lvl1":"Support material"},"content":"In this part, you can find the basic tools that will help you throughout this section. In particular, you will learn how to:\n\nwork with the pandas module: \n\nIntroduction\n\ndeal with linear regression: \n\nLinear regression - Linear model\n\nAnd more advanced topics, such as how to:\n\ntailor more advanced regression models: \n\nadvanced linear regression\n\nwork with noisy data: \n\nDerivation of numerical data\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/support-material-1","position":1},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises-1","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"Image processing exercises.\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/exercises-1","position":1},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure"},"type":"lvl1","url":"/image-processing-practical-work","position":0},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure"},"content":"In this tutorial, you will study the microstructure of an \n\nHSLA steel.\n\n\n\nRequired files\n\nDownload the image file \n\nHSLA_340.jpg and put it in the same folder as this notebook.","type":"content","url":"/image-processing-practical-work","position":1},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Introduction"},"type":"lvl2","url":"/image-processing-practical-work#introduction","position":2},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Introduction"},"content":"This image is a micrograph of a high-strength low-alloy (HSLA) steel.\nThe image was taken using a scanning electron microscope (SEM) and shows the microstructure of the steel.\nThe microstructure shows grains and separated by \n\ngrain boundaries.\nThe grains are regions of the material where the atoms are arranged in a regular pattern.\nThe grain boundaries are the interfaces between the grains.\nThe size of the grains and the distribution of the grain boundaries are important for the mechanical properties of the material.\nFor example, the \n\nHall-Petch equation relates the yield strength of a material to the average grain size.","type":"content","url":"/image-processing-practical-work#introduction","position":3},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Ressources"},"type":"lvl2","url":"/image-processing-practical-work#ressources","position":4},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Ressources"},"content":"Orientation and aspect-ratio with Positron\n\nRegion properties with Scikit-Image","type":"content","url":"/image-processing-practical-work#ressources","position":5},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Objectives"},"type":"lvl2","url":"/image-processing-practical-work#objectives","position":6},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Objectives"},"content":"In this tutorial, we will measure the grain size as well as the grain shape factor and the grain orientation.","type":"content","url":"/image-processing-practical-work#objectives","position":7},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Tasks"},"type":"lvl2","url":"/image-processing-practical-work#tasks","position":8},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl2":"Tasks"},"content":"\n\n# IF USING JUPYTER LAB, USE THE FOLLOWING COMMAND:\n%matplotlib widget\n# IF USING JUPYTER NOTEBOOK, USE THE FOLLOWING COMMAND:\n# %matplotlib notebook\n\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom scipy import ndimage\nimport pandas as pd\nimport os\n\n\n\nname = \"HSLA_340.jpg\"\nworkdir = \"./\"\nfiles = os.listdir(workdir)\nif name in files:\n    print(\"Ok, the file is in {0}\".format(files))\nelse:\n    print(\"The file is not in {0} , retry !\".format(files))\n\n\n\nim = np.array(Image.open(workdir + name))\nfig, ax = plt.subplots()\nax.axis(\"off\")\nplt.imshow(im, cmap=cm.copper)\nplt.colorbar()\nplt.show()\n\n\n\n","type":"content","url":"/image-processing-practical-work#tasks","position":9},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Histogram","lvl2":"Tasks"},"type":"lvl3","url":"/image-processing-practical-work#histogram","position":10},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Histogram","lvl2":"Tasks"},"content":"Plot the histogram of the image and find the right level for the thresholding.\n\n# CODDE HERE\n\n\n\n","type":"content","url":"/image-processing-practical-work#histogram","position":11},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Thresholding","lvl2":"Tasks"},"type":"lvl3","url":"/image-processing-practical-work#thresholding","position":12},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Thresholding","lvl2":"Tasks"},"content":"Use thresholding to convert the image to binary format.\n\n# CODDE HERE\n\n\n\n","type":"content","url":"/image-processing-practical-work#thresholding","position":13},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Labeling","lvl2":"Tasks"},"type":"lvl3","url":"/image-processing-practical-work#labeling","position":14},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Labeling","lvl2":"Tasks"},"content":"Use the ndimage.label to label each grain and plot the result.\n\n# CODDE HERE\n\n\n\n","type":"content","url":"/image-processing-practical-work#labeling","position":15},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Grain size measurement","lvl2":"Tasks"},"type":"lvl3","url":"/image-processing-practical-work#grain-size-measurement","position":16},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Grain size measurement","lvl2":"Tasks"},"content":"Use the labeled image to measure the size (in pixels) of each grain. Create a new image on which the color of each pixel indicates the size of the grain it belongs to.\n\n# CODDE HERE\n\n\n\n","type":"content","url":"/image-processing-practical-work#grain-size-measurement","position":17},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Grain shape factor and orientation","lvl2":"Tasks"},"type":"lvl3","url":"/image-processing-practical-work#grain-shape-factor-and-orientation","position":18},{"hierarchy":{"lvl1":"Practical Work: Steel microstructure","lvl3":"Grain shape factor and orientation","lvl2":"Tasks"},"content":"The cold rolling treatment modifies the shape factor as well as their orientation. Find a way to measure and represent the shape factor of each grain and to mesure their orientation.\n\n# CODDE HERE\n\n","type":"content","url":"/image-processing-practical-work#grain-shape-factor-and-orientation","position":19},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice"},"type":"lvl1","url":"/image-processing-practical-work-bonus","position":0},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice"},"content":"Python provides several great libraries that allow a wide range of operation on images. For further information, please read the tutorials of:\n\nOpenCV\n\nScikit Image\n\nIn this notebook, we just introduce a few classical image processing operations while playing with dice. The goal of the example is to count the total score one the dice, the answer being 113.\n\n%matplotlib widget\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom scipy import ndimage\nimport pandas as pd\nimport os\n\n\n\n\n\nYou can download the image used in this example here (just right-click and download):\n\n\n\nThe following code will work if the image is located in the same directory as the notebook itself.\n\nFirst, let’s check if the file “dice.jpg” is in the current directory.\n\npath = \"dice.jpg\"\nfiles = os.listdir(\"./\")\nif path in files:\n    print(\"Ok, the file is in {0}\".format(files))\nelse:\n    print(\"The file is not in {0} , retry !\".format(files))\n\n\n\nNow let’s read it using Python Image Library (aka PIL):\n\nim = Image.open(path)\nNc, Nl = im.size\nim = im.resize((Nc // 2, Nl // 2))\nfig, ax = plt.subplots()\nax.axis(\"off\")\nplt.imshow(im)\nplt.show()\n\n\n\n","type":"content","url":"/image-processing-practical-work-bonus","position":1},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Conversion to grayscale"},"type":"lvl2","url":"/image-processing-practical-work-bonus#conversion-to-grayscale","position":2},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Conversion to grayscale"},"content":"\n\nR, G, B = im.split()\nR = np.array(R)\nG = np.array(G)\nB = np.array(B)\nR\n\n\n\ntitle_list = [\n    \"Red channel\",\n    \"Green channel\",\n    \"Blue channel\",\n]\nfig, axs = plt.subplots(nrows=1, ncols=3)\nfig.tight_layout(pad=3.0)\nfor i in range(3):\n    axs[i].imshow(np.array(im)[:, :, i], cmap=\"gray\")\n    axs[i].title.set_text(title_list[i])\n\n\n\nThe green channel has a great contrats so we chose to work only on this channel now.","type":"content","url":"/image-processing-practical-work-bonus#conversion-to-grayscale","position":3},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Histogram"},"type":"lvl2","url":"/image-processing-practical-work-bonus#histogram","position":4},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Histogram"},"content":"The histogram shows the repartition of the pixels on the color scale.\n\nplt.figure()\nplt.hist(G.flatten(), bins=np.arange(255))\nplt.title(\"Green channel histogram\")\nplt.xlabel(\"Pixel value\")\nplt.ylabel(\"Count\")\nplt.show()\n\n\n\n","type":"content","url":"/image-processing-practical-work-bonus#histogram","position":5},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Thresholding"},"type":"lvl2","url":"/image-processing-practical-work-bonus#thresholding","position":6},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Thresholding"},"content":"Using the histogram, one can see that there are 3 peaks. The left peak is the darkest one and corresponds to the colors of the dice bodies. We can cut around 120 to isolate the dice bodies from the pips on the dice.\n\nFurther reading: \n\nThresholding (Scikit)\n\nimport ipywidgets as widgets\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# set up plot\nfig, ax = plt.subplots(figsize=(6, 4))\n\n\n@widgets.interact(low_tresh=(0, 255, 1))\ndef update(low_tresh=120):\n    \"\"\"Remove old lines from plot and plot new one\"\"\"\n    plt.cla\n    Gb = np.zeros_like(G)\n    Gb = np.where(G > low_tresh, 1, Gb)\n    ax.imshow(Gb, cmap=\"binary\")\n\n\n\n\n\n","type":"content","url":"/image-processing-practical-work-bonus#thresholding","position":7},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Erosion / Dilation"},"type":"lvl2","url":"/image-processing-practical-work-bonus#erosion-dilation","position":8},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Erosion / Dilation"},"content":"\n\n# CODE HERE\n\n\n\n","type":"content","url":"/image-processing-practical-work-bonus#erosion-dilation","position":9},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Labeling"},"type":"lvl2","url":"/image-processing-practical-work-bonus#labeling","position":10},{"hierarchy":{"lvl1":"Practical Work Bonus: Play with dice","lvl2":"Labeling"},"content":"\n\n# CODE HERE\n\n","type":"content","url":"/image-processing-practical-work-bonus#labeling","position":11},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling"},"type":"lvl1","url":"/image-processing-tutorial","position":0},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling"},"content":"","type":"content","url":"/image-processing-tutorial","position":1},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Introduction"},"type":"lvl2","url":"/image-processing-tutorial#introduction","position":2},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Introduction"},"content":"The goal of this tutorial is to learn basic image processing skills using a simple picture of coins on a table. Your task is to identify and count the coins.\nYou can use the following image or take a picture of your own and work with it.\n\n","type":"content","url":"/image-processing-tutorial#introduction","position":3},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Setup"},"type":"lvl2","url":"/image-processing-tutorial#setup","position":4},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Setup"},"content":"\n\n%matplotlib widget\nfrom skimage import io\nimport numpy as np\nfrom matplotlib import pyplot as plt\nfrom matplotlib import cm\nfrom scipy import ndimage\nimport os\n\n\n\n\n\n","type":"content","url":"/image-processing-tutorial#setup","position":5},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Open the file"},"type":"lvl2","url":"/image-processing-tutorial#open-the-file","position":6},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Open the file"},"content":"\n\npath = \"coins.jpg\"\nfiles = os.listdir(\"./\")\nif path in files:\n    print(\"Ok, the file is in {0}\".format(files))\nelse:\n    print(\"The file is not in {0} , retry !\".format(files))\n\n\n\nim = io.imread(path)\nplt.figure()\nplt.imshow(im)\nplt.show()\n\n\n\nprint(f\"The image is a {type(im)}\")\nprint(f\"The shape of this numpy array is {im.shape} and the data type is {im.dtype}\")\nprint(f\"This image has {im.size} pixels\")\nprint(f\"The height is {im.shape[0]} and the width is {im.shape[1]}\")\nprint(f\"The image has {im.shape[2]} channels\")\n\n\n\n","type":"content","url":"/image-processing-tutorial#open-the-file","position":7},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Plot the histogram"},"type":"lvl2","url":"/image-processing-tutorial#plot-the-histogram","position":8},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Plot the histogram"},"content":"Plot the histogram of the image.\n\n# CODE HERE\n\n\n\n","type":"content","url":"/image-processing-tutorial#plot-the-histogram","position":9},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Thresholding"},"type":"lvl2","url":"/image-processing-tutorial#thresholding","position":10},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Thresholding"},"content":"Use thresholding to convert the image to a binary format.\n\n# CODE HERE\n\n\n\n","type":"content","url":"/image-processing-tutorial#thresholding","position":11},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Erosion / Dilation"},"type":"lvl2","url":"/image-processing-tutorial#erosion-dilation","position":12},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Erosion / Dilation"},"content":"Use erosion and dilation to clean the image if needed to isolate each coin.\n\n# CODE HERE\n\n\n\n","type":"content","url":"/image-processing-tutorial#erosion-dilation","position":13},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Labeling"},"type":"lvl2","url":"/image-processing-tutorial#labeling","position":14},{"hierarchy":{"lvl1":"Tutorial: Counting objects using labeling","lvl2":"Labeling"},"content":"Use the labeling (scipy.ndimage.measurements.label) algorithm to isolate each coin.\n\n# CODE HERE\n\n","type":"content","url":"/image-processing-tutorial#labeling","position":15},{"hierarchy":{"lvl1":"Orientation an aspect ratio"},"type":"lvl1","url":"/blob-orientation","position":0},{"hierarchy":{"lvl1":"Orientation an aspect ratio"},"content":"In this example, we show how to use inertia matrix of a given labeled object to find its orientation.\n\nRequired files\n\nBefore using this notebook, download the image \n\nblobs.jpg\n\n%matplotlib widget\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom scipy import ndimage\nimport pandas as pd\nimport os\n\n\n\npath = \"blobs.jpg\"\nfiles = os.listdir(\"./\")\nif path in files:\n    print(\"Ok, the file is in {0}\".format(files))\nelse:\n    print(\"The file is not in {0} , retry !\".format(files))\n\n\n\nIn order to explain the concepts of inertia and aspect ratio, we use this magnificient hand drawing:\n\nim = Image.open(path)\nNc, Nl = im.size\nim = im.resize((Nc // 4, Nl // 4))\nfig, ax = plt.subplots()\n# ax.axis(\"off\")\nplt.imshow(im)\nplt.colorbar()\nplt.show()\n\n\n\nR, G, B = im.split()\nR = np.array(R)\nG = np.array(G)\nB = np.array(B)\n\n\n\nplt.figure()\nplt.hist(\n    R.flatten(),\n    bins=np.arange(256),\n    histtype=\"stepfilled\",\n    color=\"r\",\n    alpha=0.3,\n    label=\"Red\",\n)\nplt.hist(\n    G.flatten(),\n    bins=np.arange(256),\n    histtype=\"stepfilled\",\n    color=\"g\",\n    alpha=0.3,\n    label=\"Green\",\n)\nplt.hist(\n    B.flatten(),\n    bins=np.arange(256),\n    histtype=\"stepfilled\",\n    color=\"b\",\n    alpha=0.3,\n    label=\"Blue\",\n)\nplt.grid()\nplt.legend()\nplt.show()\n\n\n\nThresholding level is obvious:\n\nBt = np.where(B < 50, 1, 0)\nplt.figure()\nplt.imshow(Bt, cmap=cm.gray)\nplt.colorbar()\nplt.show()\n\n\n\nBtc = ndimage.binary_closing(Bt, structure=np.ones((5, 5)))\n\n\nBl, number = ndimage.label(Btc)\nplt.figure()\nplt.imshow(np.where(Bl != 0, Bl, np.nan), cmap=cm.jet)\nplt.show()\nnumber\n\n\n\n\n\nobj = ndimage.find_objects(Bl)\nlen(obj)\n\n\n\n","type":"content","url":"/blob-orientation","position":1},{"hierarchy":{"lvl1":"Orientation an aspect ratio","lvl2":"Inertia matrix of an object"},"type":"lvl2","url":"/blob-orientation#inertia-matrix-of-an-object","position":2},{"hierarchy":{"lvl1":"Orientation an aspect ratio","lvl2":"Inertia matrix of an object"},"content":"The object represented bellow is stretched in a direction. Let’s see how we can use its inertia matrix to determine in which direction and how much it is stretched.\n\nplt.figure()\nplt.imshow(np.array(im)[obj[1]])\nplt.show()\n\n\n\nThe inertia matrix of a 2D object can be defined as follows:I = \n\\begin{bmatrix} \nI_{xx} & -I_{xy} \\\\\n-I_{xy} & I_{yy} \\\\\n\\end{bmatrix}\n\nThis matrix is symmetric and, as a consequence, it can be diagonalized in a new frame rotated by an angle \\theta in the plane. This frame is composed of the two normalized eigenvectors (\\vec e_1, \\vec e_2) of the matrix. In this frame, the matrix has two eigenvalues (I_1, I_2) ordered so that I_1 \\geq I_2. Then:\n\n\\theta = (\\vec x, \\vec e_1) and,\n\nThe aspect ratio a = \\sqrt{I_1 / I_2}.\n\nThe angle \\theta gives the direction of the elongation of the object and a shows how much it is elongated. For example,  if a == 1, the object is not elongated whereas if a=10 it is 10 times longer in direction 1 than in direction 2 in an inertial point of view.\n\ndata = pd.DataFrame(\n    columns=[\"area\", \"xg\", \"yg\", \"Ixx\", \"Iyy\", \"Ixy\", \"I1\", \"I2\", \"theta\"]\n)\nfor i in range(len(obj)):\n    x, y = np.where(Bl == i + 1)\n    xg, yg = x.mean(), y.mean()\n    x = x - xg\n    y = y - yg\n    A = len(x)\n    Ixx = (y**2).sum()\n    Iyy = (x**2).sum()\n    Ixy = (x * y).sum()\n    I = np.array([[Ixx, -Ixy], [-Ixy, Iyy]])\n    eigvals, eigvecs = np.linalg.eig(I)\n    eigvals = abs(eigvals)\n    loc = np.argsort(eigvals)[::-1]\n    d = eigvecs[loc[0]]\n    d *= np.sign(d[0])\n    theta = np.degrees(np.arccos(d[1]))\n    eigvals = eigvals[loc]\n    data.loc[i] = [A, xg, yg, Ixx, Iyy, Ixy, eigvals[0], eigvals[1], theta]\ndata.sort_values(\"area\", inplace=True, ascending=False)\ndata[\"aspect_ratio\"] = (data.I1 / data.I2) ** 0.5\n\ndata[[\"area\", \"theta\", \"aspect_ratio\"]]\n\n\n\nfig = plt.figure()\ncounter = 1\nfor i in data.index.values:\n    ax = fig.add_subplot(3, 4, counter)\n    z = Image.fromarray(np.array(im)[obj[i]])\n    z = z.rotate(-data.loc[i, \"theta\"] + 90, expand=True)\n    z = np.array(z)\n    plt.imshow(z)\n    plt.title(str(i))\n    ax.axis(\"off\")\n    counter += 1\n    # plt.grid()\nplt.show()\n\n\n\n\n\n","type":"content","url":"/blob-orientation#inertia-matrix-of-an-object","position":3},{"hierarchy":{"lvl1":"Basics"},"type":"lvl1","url":"/image-processing-basics","position":0},{"hierarchy":{"lvl1":"Basics"},"content":"In this notebook, we introduce basic ways to read, show, explore and save images.\n\n%matplotlib notebook\nfrom PIL import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\nfrom scipy import ndimage\nfrom IPython.display import YouTubeVideo\nimport os\n\n\n\n","type":"content","url":"/image-processing-basics","position":1},{"hierarchy":{"lvl1":"Basics","lvl2":"Preamble"},"type":"lvl2","url":"/image-processing-basics#preamble","position":2},{"hierarchy":{"lvl1":"Basics","lvl2":"Preamble"},"content":"Before going into the technical details, we strongly recommend these two videos from the excellent YouTube channel Dirty Biology:\n\n\n\n\n\n","type":"content","url":"/image-processing-basics#preamble","position":3},{"hierarchy":{"lvl1":"Basics","lvl2":"Loading an image"},"type":"lvl2","url":"/image-processing-basics#loading-an-image","position":4},{"hierarchy":{"lvl1":"Basics","lvl2":"Loading an image"},"content":"To read an image with Python, the easiest way is to use the Python Image Library (PIL) which provides the basic tools.\n\n\n\nRequired files\n\nBefore using this notebook, download the image \n\nrabbit.jpg\n\nThe following code will work if the image is located in the same directory as the notebook itself. First, let’s check if the file rabbit.jpg is in the current directory.\n\nfiles = os.listdir(\"./\")\nif \"rabbit.jpg\" in files:\n    print(\"Ok, the file is in {0}\".format(files))\nelse:\n    print(\"The file is not in {0} , retry !\".format(files))\n\n\n\nNow let’s read it using Python Image Library (aka PIL):\n\nim = Image.open(\"rabbit.jpg\")\nim\n\n\n\n","type":"content","url":"/image-processing-basics#loading-an-image","position":5},{"hierarchy":{"lvl1":"Basics","lvl2":"Numerical images"},"type":"lvl2","url":"/image-processing-basics#numerical-images","position":6},{"hierarchy":{"lvl1":"Basics","lvl2":"Numerical images"},"content":"There are mainly two kinds of numerical images:\n\nVector images composed of basic geometric figures such as lines and polygons. They are very efficient to store schemes or curves. They are generally stored as .svg, .pdf or .eps files. In this tutorial, we will not work on such images.\n\nRaster images, also called bitmaps in which data is structures as matrix of pixels. Each pixel can contain from 1 to 4 values called channels. Images can then be sub classed by their number of channels:\n\nA single channel image is called grayscale,\n\nMost color images use 3 channels, one for red (R), one for green (G) and one for blue (B). They are called RGB images.\n\nSome image formats use a fourth channel called alpha corresponding to the transparency level of a given pixel.\n\nIn the following, we focus on raster images. In the current image, the channel structure can be obtained as follows:\n\n","type":"content","url":"/image-processing-basics#numerical-images","position":7},{"hierarchy":{"lvl1":"Basics","lvl2":"From image to numpy"},"type":"lvl2","url":"/image-processing-basics#from-image-to-numpy","position":8},{"hierarchy":{"lvl1":"Basics","lvl2":"From image to numpy"},"content":"In practice, we will manipulate the images in the form of arrays. With Python, the numpy library is the essential tool for this task. It is therefore necessary to know how to switch easily from an image to arrays and vice versa.\n\nNow, the channel data can be extracted as follows:\n\nR, G, B = im.split()  # Three channels: Red, Green and Blue\nR = np.array(R)\nG = np.array(G)\nB = np.array(B)\n\n\n\nfig, axes = plt.subplots(nrows=1, ncols=3)\naxes[0].set_title(\"R\")\naxes[0].imshow(R, \"gray\")\naxes[0].axis(\"off\")\naxes[1].set_title(\"G\")\naxes[1].imshow(G, \"gray\")\naxes[1].axis(\"off\")\naxes[2].set_title(\"B\")\naxes[2].imshow(B, \"gray\")\naxes[2].axis(\"off\")\nplt.show()\n\n\n\n\n\nAt this stage, an image is no more than a matrix generally made up of unsigned 8-bit integers (np.uint8). A color image is therefore made up of 3 grayscale images corresponding to the 3 channels:\n\nR\n\n\n\n","type":"content","url":"/image-processing-basics#from-image-to-numpy","position":9},{"hierarchy":{"lvl1":"Basics","lvl2":"From numpy to image"},"type":"lvl2","url":"/image-processing-basics#from-numpy-to-image","position":10},{"hierarchy":{"lvl1":"Basics","lvl2":"From numpy to image"},"content":"Let’s see now how to switch back from an array to a real image.\n\nr2 = np.arange(256).astype(np.uint8)\ng2 = np.arange(256).astype(np.uint8)\nR2, G2 = np.meshgrid(r2, g2)\nB2 = np.zeros_like(R2).astype(np.uint8)\n\n\n\nim2 = Image.fromarray(np.dstack([R2, G2, B2]))\nim2\n\n\n\nLet’s apply that to the rabbit image. For example, we can switch channels:\n\nim3 = Image.fromarray(np.dstack([G, R, B]))\nim3\n\n\n\n","type":"content","url":"/image-processing-basics#from-numpy-to-image","position":11},{"hierarchy":{"lvl1":"Basics","lvl2":"How a filter is applied to an image ?"},"type":"lvl2","url":"/image-processing-basics#how-a-filter-is-applied-to-an-image","position":12},{"hierarchy":{"lvl1":"Basics","lvl2":"How a filter is applied to an image ?"},"content":"This video from the excellent YouTube channel 3Blue1Brown explains how a filter is applied to an image through a convolution operation.\nAn example with the application of a Gaussian filter is presented.\n\n","type":"content","url":"/image-processing-basics#how-a-filter-is-applied-to-an-image","position":13},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material","position":0},{"hierarchy":{"lvl1":"Support material"},"content":"In this part, you can find the basic tools that will help you throughout this section. In particular, you will learn how to:\n\nRead an image.\n\nCreate an image.\n\nPerform a histogram and thresholding to binarize it.\n\nPerform an erosion or a dilation to modify the structure.\n\nCount objects with a labeling algorithm.\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/support-material","position":1},{"hierarchy":{"lvl1":"POSITRON: PythOn for Science In The Reblochon cOuNtry"},"type":"lvl1","url":"/","position":0},{"hierarchy":{"lvl1":"POSITRON: PythOn for Science In The Reblochon cOuNtry"},"content":"Positron is a repository made collectively by several teachers and researchers from Annecy in France. It contains resources and exercises dealing with several topics related to numerical methods. They use the Python language. Most of the pages are in Jupyter format. They are therefore downloadable, modifiable and interactive.\n\nThe resources available are intended to give practical skills to students. They are not designed as exhaustive sources but more as tools to provide beginners with the basics.\n\nIt is divided by themes as follows:\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network\n\nThe contributors to this project are:\n\nLudovic Charleux\n\nEmile Roux\n\nChristian Elmo\n\nLegacy contributors:\n\nThibault Goyallon\n\nGiovanni Feverati\n\nPierre Nagorny\n\nCamille Saint-Martin","type":"content","url":"/","position":1},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises-5","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"In this section, we propose quick exercises that can typically be done in an hour and a half.:\n\nSupervised learning using PyTorch: a toy example (duration: 1.5 h): Introductory exercise that will make you use a neural network modeled with PyTorch to classify points in supervised learning.","type":"content","url":"/exercises-5","position":1},{"hierarchy":{"lvl1":"Exercices","lvl2":"Practical work"},"type":"lvl2","url":"/exercises-5#practical-work","position":2},{"hierarchy":{"lvl1":"Exercices","lvl2":"Practical work"},"content":"In this section, we propose longer exercises that can be done without assistance, typically in 4 hours.\n\nReinforcement learning on snake with a genetic neural network (duration: 4 h): An example of supervised learning applied to video games. You will use the legendary game Snake rewritten in Python for the occasion and will try to develop an automatic game strategy. In a first step, by hand and in a second step using a genetic algorithm to evolve a neural network. Graphical examples will allow to see the evolution of the game performances.","type":"content","url":"/exercises-5#practical-work","position":3},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example"},"type":"lvl1","url":"/classification-demo","position":0},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example"},"content":"","type":"content","url":"/classification-demo","position":1},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Introduction"},"type":"lvl2","url":"/classification-demo#introduction","position":2},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Introduction"},"content":"In this example, you will use a supervised learning strategy to train a neural network.\nThe example is deliberately very simple to allow for great scalability and fast CPU learning.\n\n%matplotlib widget\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nimport pandas as pd\nfrom scipy import optimize\nimport numba\nimport torch\nfrom IPython.display import YouTubeVideo\n\n\n\nYouTubeVideo(\"aircAruvnKk\")\n\n\n\n","type":"content","url":"/classification-demo#introduction","position":3},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Exact model"},"type":"lvl2","url":"/classification-demo#exact-model","position":4},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Exact model"},"content":"In this first part, we propose to define an ideal classification model. It is a function which associates a value z \\in \\left\\lbrace 0, 1 \\right \\rbrace to a tuple of values (x, y). This function represents categories or classes that we would like to model the distribution in space. In a real case, this function would be inaccessible to us and we would try to find it through deep learning.\n\nWe propose two examples of functions but you are encouraged to develop your own and to test them.\n\ndef func_easy(inp):\n    \"\"\"\n    A ideal model.\n    \"\"\"\n    xc1, yc1 = 0.3, 0.6\n    xc2, yc2 = 0.55, 0.15\n    r1, r2 = 0.25, 0.15\n    X, Y = np.array(inp).T\n    R12 = (X - xc1) ** 2 + (Y - yc1) ** 2\n    R22 = (X - xc2) ** 2 + (Y - yc2) ** 2\n    return ((R22 <= r2**2) | (R12 <= r1**2)) * 1\n\n\ndef func_hard(inp):\n    \"\"\"\n    Another ideal model, just a bit more complex.\n    \"\"\"\n    x, y = np.array(inp).T - 0.5\n    r = np.sqrt(x**2 + y**2)\n    theta = np.arccos(x / r) * np.sign(y)\n    out = (np.cos(3 * theta + 10 * r) >= 0.0) * 1\n    out[r <= 0.1] = 1\n    return out\n\n\nexact_model = func_easy\n\n\n\nIn what follows, we draw the model to see what it looks like.\n\nnxm, nym = 200, 200\nxm = np.linspace(0, 1.0, nxm)\nym = np.linspace(0, 1.0, nym)\nXm, Ym = np.meshgrid(xm, ym)\npointsm = np.array([Xm.flatten(), Ym.flatten()]).T\nsolm = exact_model(pointsm)\nsolm\n\n\n\nfig, ax = plt.subplots(1, 1)\nax.set_aspect(\"equal\")\nplt.scatter(\n    pointsm[solm == 1].T[0], pointsm[solm == 1].T[1], s=1, color=\"white\", label=\"Ones\"\n)\nplt.scatter(\n    pointsm[solm == 0].T[0], pointsm[solm == 0].T[1], s=1, color=\"black\", label=\"Zeros\"\n)\nplt.legend()\nplt.show()\n\n\n\n","type":"content","url":"/classification-demo#exact-model","position":5},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Learning DB"},"type":"lvl2","url":"/classification-demo#learning-db","position":6},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Learning DB"},"content":"First, we will create a learning database. This one contains a certain number of points for which we know the class. The goal is to present them to our neural network so that it can learn to recognize the different classes. These points are randomly arranged in the space where the function is defined. We can vary the number of points and see how this affects the learning capacity of the network.\n\nnpl = 2000  # NUMBER OF SAMPLES\npointsl = np.random.rand(npl * 2).reshape(npl, 2)\nsoll = exact_model(pointsl)\n\n\n\nfig, ax = plt.subplots(1, 1)\nax.set_aspect(\"equal\")\nplt.scatter(\n    pointsl[soll == 1].T[0], pointsl[soll == 1].T[1], s=2, color=\"red\", label=\"Ones\"\n)\nplt.scatter(\n    pointsl[soll == 0].T[0], pointsl[soll == 0].T[1], s=2, color=\"blue\", label=\"Zeros\"\n)\nplt.legend()\nplt.show()\n\n\n\n","type":"content","url":"/classification-demo#learning-db","position":7},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Neural Network class"},"type":"lvl2","url":"/classification-demo#neural-network-class","position":8},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Neural Network class"},"content":"A neural network is a stack of alternating layers. Linear layers where a linear (or affine) function is applied to the data and non-linear layers where a non-linear function or activation function (or neural function) is applied to the data. Building a network is therefore a matter of choosing the number of layers and the type of neural functions. The learning process only consists in optimizing the weights present in the linear layers. Neural functions do not usually have adjustable parameters.\n\nEvaluating the result of the network (inference) is the same as going from left to right, we speak of a forward path. On the contrary, to make it learn in a supervised approach, we have to analyze the effect of the different weights on the result and on the error it generates. This is called a backward path.\n\nYou are asked to create your network and to test it.","type":"content","url":"/classification-demo#neural-network-class","position":9},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Required work"},"type":"lvl2","url":"/classification-demo#required-work","position":10},{"hierarchy":{"lvl1":"Supervised learning using PyTorch: a toy example","lvl2":"Required work"},"content":"Try the code in the state it is in. Do you think it is effective?\n\nIn particular, compare the level of error displayed during learning with the quality of the figure obtained at the end of the notebook.\n\nTry to improve it by playing on: the training dataset, the network structure. Draw conclusions.\n\nTry the different neural functions and see how they affect the behavior of the network.\n\nTry the func_hard function (see above), which has a more difficult structure to reproduce than the default.\n\ndevice = \"cpu\"\nerrors = []\nsteps = []\n# BUILD LAYERS WITH:\n# LINEAR LAYERS:\ntorch.nn.Linear(2, 4, bias=True)  # LINEAR LAYERS\n# NEURAL FUNCTIONS:\ntorch.nn.ELU, torch.nn.ReLU, torch.nn.Hardtanh  # POSSIBLE ACTIVATION FUNCTIONS\nactivation_func = torch.nn.ReLU\n\n# LAYERS INITIALIZATION\nlayers = [\n    torch.nn.Linear(2, 4, bias=True),\n    activation_func(),\n    torch.nn.Linear(4, 1, bias=True),\n    torch.nn.Hardtanh(min_val=0.0, max_val=1.0),\n]\nmodel = torch.nn.Sequential(*layers).to(device)\nlayers\n\n\n\n# TRAINING INPUTS / OUTPUTS\n# NOTE: YOU CAN RERUN THIS CELL TO CONTINUE TRAINING PROCESS\nrun_training = True  # SET TO True TO ACTUALLY RUN TRAINING\nif run_training:\n    x = torch.Tensor(pointsl).to(device)\n    t = torch.Tensor(soll[:, None]).to(device)\n    ns = x.shape[0]\n    learning_rate = 1e-3\n    optimizer = torch.optim.Adam(model.parameters(), lr=learning_rate)\n    loss_fn = torch.nn.MSELoss(reduction=\"sum\").to(device)\n    Ne = 10  # Number of training epoch\n    Nes = 100  # Number of training steps per epoch\n    error = np.zeros(Ne)\n    step = np.arange(Ne) * Nes\n    if len(steps) != 0:\n        step += steps[-1].max() + Nes\n    # TRAINING\n    for e in range(Ne):\n        for s in range(Nes):\n            y = model(x)\n            loss = loss_fn(y, t)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n        error[e] = loss.item() / ns\n        err_str = \"{0:.3f}\".format(error[e] * 100).zfill(6)\n        print(f\"Loss = {err_str}\")\n    errors.append(error)\n    steps.append(step)\n\n# POST-PROCESSING\nif run_training:\n    errors2 = np.array(errors)\n    fig = plt.figure()\n    plt.title(\"Training process\")\n    # plt.yscale(\"log\")\n    for ep, err in enumerate(errors2):\n        plt.plot(steps[ep], err * 100, \"x-\", label=f\"Epoch {ep}\")\n    plt.xlabel(\"Steps\")\n    plt.ylabel(\"Loss [%]\")\n    # plt.yscale(\"log\")\n    plt.legend()\n    plt.grid()\n\n\n\nif run_training:\n    yt = model(torch.Tensor(pointsm).to(device)).cpu().data.numpy().ravel()\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 3, 1)\n    ax.set_aspect(\"equal\")\n    plt.title(\"Model\")\n    plt.tricontourf(pointsm.T[0], pointsm.T[1], solm, 2, cmap=mpl.cm.gray)\n    ax.axis(\"off\")\n    ax = fig.add_subplot(1, 3, 2)\n    ax.set_aspect(\"equal\")\n    plt.title(\"Learned\")\n    plt.tricontourf(pointsm.T[0], pointsm.T[1], yt, cmap=mpl.cm.gray)\n    ax.axis(\"off\")\n    ax = fig.add_subplot(1, 3, 3)\n    ax.set_aspect(\"equal\")\n    plt.title(\"Error\")\n    plt.tricontourf(pointsm.T[0], pointsm.T[1], yt - solm, cmap=mpl.cm.gray)\n    ax.axis(\"off\")\n    plt.show()\n\n","type":"content","url":"/classification-demo#required-work","position":11},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network"},"type":"lvl1","url":"/genetic-snake-practical-work","position":0},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network"},"content":"# UNCOMMENT FOR INTERACTIVE PLOTTING\n# %matplotlib notebook\n%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation, rc, cm\nimport time\nfrom snakelib import FastSnake, show_gui, NeuralAgent\nimport snakelib as snklib\nimport utils\nfrom scipy.ndimage import label\n\nrc(\"animation\", html=\"html5\")\n\n\n\n\n\n\n\n","type":"content","url":"/genetic-snake-practical-work","position":1},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network"},"type":"lvl1","url":"/genetic-snake-practical-work#ml-practical-work-genetic-snake","position":2},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network"},"content":"Required files\n\nIn order to work properly, this notebook requires the following modules in its folder:\n\nsnakelib.py\n\nutils.py\n\nPut it in your working directory along with this notebook.\n\nThis notebook is an example of supervised learning applied to video games. You will use the legendary game Snake rewritten in Python for the occasion and will try to develop an automatic game strategy. In a first step, by hand and in a second step using a genetic algorithm to evolve a neural network. Graphical examples will allow to see the evolution of the game performances.","type":"content","url":"/genetic-snake-practical-work#ml-practical-work-genetic-snake","position":3},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Part 1: Try the game"},"type":"lvl2","url":"/genetic-snake-practical-work#part-1-try-the-game","position":4},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Part 1: Try the game"},"content":"\n\nIn this first part, you are asked to try the game and check that you understand the rules. Try to imagine what you need to know to win a game.\n\nnp.random.seed(0)  # Fixing the seed\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nsnake = FastSnake(Nrow=10, Ncol=10)\ndisplay(show_gui(snake, ax))\n\n\n\n\n\nplt.close()\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#part-1-try-the-game","position":5},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl3","url":"/genetic-snake-practical-work#some-explications","position":6},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"","type":"content","url":"/genetic-snake-practical-work#some-explications","position":7},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"1. Game Grid","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl4","url":"/genetic-snake-practical-work#id-1-game-grid","position":8},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"1. Game Grid","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"The game grid is composed of a number of columns noted Ncol and a number of lines noted Nrow.\n\nprint(\n    f\"Grid dimensions: {snake.Ncol} columns, {snake.Nrow} rows, a total of {snake.Ncell} elements\"\n)\n\n\n\nEach element of the grid is identified by an unique index.\n\nutils.plot_grid(snake)\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#id-1-game-grid","position":9},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"2. Snake directions","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl4","url":"/genetic-snake-practical-work#id-2-snake-directions","position":10},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"2. Snake directions","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"From the current position of its head, the snake can only take three directions at each turn, it can go to its right, forward and left.\n\nHere, an example of commands that allow you to move the snake :\n\n# Moving the snake\nnp.random.seed(0)  # Fixing the seed\nsnake.reset()  # Reset snake position\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(1)  # Go Left\n\n# Access to neighbors element positions\nprint(f\"Current neighbors index {snake.get_neighbors_pos()}\")\n\n\n\nNote\n\nYou notice that the value -1 turn the snake to the right, 0 in front and 1 to the left relatively to the current snake direction.\n\nHere are the results of the actions taken by these various successive orders:\n\nutils.plot_snake(snake)\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#id-2-snake-directions","position":11},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"Question 1","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl4","url":"/genetic-snake-practical-work#question-1","position":12},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"Question 1","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"What commands must be given for the snake to eat the first fruit ?\n\n# Initial snake position\nnp.random.seed(0)  # Fixing the seed\nsnake.reset()  # Reset snake position\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(1)  # Go Left\n\n# Your answer\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\ndisplay(show_gui(snake, ax))\n\n\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#question-1","position":13},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl4","url":"/genetic-snake-practical-work#id-3-snake-sensors","position":14},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"\n\nIt turns out that in their infinite wisdom, the game designers gave the snake some very weird sensors to help the players.\nHere’s how to display the sensor data:","type":"content","url":"/genetic-snake-practical-work#id-3-snake-sensors","position":15},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl5":"Default sensors:","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl5","url":"/genetic-snake-practical-work#default-sensors","position":16},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl5":"Default sensors:","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"\n\n# Moving the snake\nnp.random.seed(0)  # Fixing the seed\nsnake.reset()  # Reset snake position\nsnake.display_sensor_method = \"default\"\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\ndisplay(show_gui(snake, ax))\n\n\n\n\n\nThe first 3 elements indicate respectively the nature of the boxes directly to the right, in front of and to the left of the snake’s head (relative to its direction).\n\nThe values of the elements can be:\n\n1.0 = fruit present\n\n-1.0 = forbidden position (lava or snake tail)\n\n0.0 = nothing special present\n\nutils.plot_snake(snake)\n\n\n\nExample\n\nThe head of the snake is in position 11.\nTo its left is lava, a value of -1 is read on the first element of the sensors output.\nTo its right, there is nothing, a value of 0 is read on the third element of the sensors output.\n\nThe last two data give the relative directions of the fruit relative to the head of the snake.\nIndeed, there is an angle \\theta between the direction of the snake and the position of the fruit on the grid.\n\nThese last two values are respectively the sign of \\cos(\\theta) and \\sin(\\theta).\n\n# Moving the snake\nnp.random.seed(0)  # Fixing the seed\nsnake.reset()  # Reset snake position\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(-1)  # Go Right\nsnake.turn(0)  # Go Front\nsnake.turn(1)  # Go Left\n\n# Snake current direction\ndirection = snake.get_current_direction()\nprint(f\"Current direction: {direction}\")\n\n\n\nThe current direction of the snake based on the positions of its head and neck.\ndirection (int): An integer representing the current direction of the snake, where:\n    0 = right\n    1 = up\n    2 = left\n    3 = down\n    -1 = if the direction could not be determined\n\nutils.plot_snake_theta(snake)\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#default-sensors","position":17},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl5":"Advanced sensors: label sensors","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"type":"lvl5","url":"/genetic-snake-practical-work#advanced-sensors-label-sensors","position":18},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl5":"Advanced sensors: label sensors","lvl4":"3. Snake sensors","lvl3":"Some explications","lvl2":"Part 1: Try the game"},"content":"The label sensors have the same shape as the “default” sensors. The main difference is that they identify the number of free cases that are reachable with a given choice. If the number of reachable cells is the maximum, it returns 1. Otherwise, it returns -1. If there is no reachable cell, it returns -1.\n\n# Moving the snake\nnp.random.seed(0)  # Fixing the seed\nsnake.reset()  # Reset snake position\nsnake.display_sensor_method = \"label\"\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\ndisplay(show_gui(snake, ax))\n\n\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#advanced-sensors-label-sensors","position":19},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Automatic playing"},"type":"lvl2","url":"/genetic-snake-practical-work#automatic-playing","position":20},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Automatic playing"},"content":"","type":"content","url":"/genetic-snake-practical-work#automatic-playing","position":21},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Question 2","lvl2":"Automatic playing"},"type":"lvl3","url":"/genetic-snake-practical-work#question-2","position":22},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Question 2","lvl2":"Automatic playing"},"content":"At first, you are asked to build an agent that will play automatically. It will have to make decisions according to the snake’s sensor values. These decisions are to choose the best direction to take.\n\nHere an example of a very dummy agent:\n\ndef my_agent(sensors):\n    \"\"\"\n    A dummy agent that moves in a random direction.\n    \"\"\"\n    return np.random.randint(3) - 1\n\n\nsnake = FastSnake(Nrow=10, Ncol=10)\nmy_choice = my_agent(snake.sensors())\n\n\n\n# Your answer\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#question-2","position":23},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Automatic play with graphic output"},"type":"lvl2","url":"/genetic-snake-practical-work#automatic-play-with-graphic-output","position":24},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Automatic play with graphic output"},"content":"\n\nsnake5 = FastSnake(Nrow=15, Ncol=15)\n\n\ndef updatefig(*args):\n    sensors = snake5.sensors(method=\"label\")\n    my_choice = my_agent(sensors)\n    snake5.turn(my_choice)\n    im2.set_array(snake5.grid)\n    score = snake5.score\n    iteration = snake5.iteration\n    title2.set_text(f\"Score = {score} Iteration = {iteration}\")\n    if snake5.status != 0:\n        snake5.reset()\n    return (im2,)\n\n\nfig2, ax2 = plt.subplots()\nax2.axis(\"off\")\nim2 = plt.imshow(snake5.grid, interpolation=\"nearest\", animated=True)\nscore = snake5.score\ntitle2 = ax2.set_title(f\"Score = {score}\", animated=True)\nanim = animation.FuncAnimation(fig2, updatefig, frames=40, interval=50, blit=True)\n# plt.show()  # UNCOMMENT TO PLAY\nplt.close()  # COMMENT TO PLAY\nanim  # COMMENT TO PLAY\n\n\n\nanim.pause()\nplt.close(fig2)\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#automatic-play-with-graphic-output","position":25},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Benchmark"},"type":"lvl2","url":"/genetic-snake-practical-work#benchmark","position":26},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Benchmark"},"content":"\n\nNagent_ids = 200\nmax_turns = 1000\nsnake3 = FastSnake(Nrow=10, Ncol=10)\nscores = np.zeros(Nagent_ids)\nturns = np.zeros(Nagent_ids)\n# for agent_id in tqdm.trange(Nagent_ids):\nfor agent_id in range(Nagent_ids):\n    snake3.reset()\n    turn = 0\n    while snake3.status == 0:\n        sensors = snake3.sensors()\n        my_choice = my_agent(sensors)\n        snake3.turn(my_choice)\n        turn += 1\n        if turn >= max_turns:\n            break\n    scores[agent_id] = snake3.score\n    turns[agent_id] = turn\n\n\n\ndata = pd.DataFrame({\"score\": scores, \"turns\": turns})\ndata.describe().loc[[\"mean\", \"std\", \"max\", \"min\", \"count\"]].T\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#benchmark","position":27},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Genetic Neural Network agent"},"type":"lvl2","url":"/genetic-snake-practical-work#genetic-neural-network-agent","position":28},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl2":"Genetic Neural Network agent"},"content":"\n\n# NEURAL FUNCTIONS\ndef sigmoid(x):\n    return 1.0 / (1.0 + np.exp(-x))\n\n\ndef ReLu(x):\n    return np.where(x > 0.0, x, 0.0)\n\n\ndef identity(x):\n    return x\n\n\n# ARG MAX\ndef argMax(x):\n    return int(np.where(x == x.max())[0][0])\n\n\n\n# GENETIC ALGORITHM SETUP\n\nNpop = 100  # NUMBER OF INDIVIDUALS IN THE POPULATION\nNgen = 5  # NUMBER OF GENERATIONS OF EVOLUTION\nNtries = 1  # NUMBER OF TRIES PER INDIVIDUAL PER GENERATION\nNet_struct = 5, 3  # NETWORK STRUCTURE\nkeep_ratio = 0.2  # # GENETIC ALGORITHM KEEP RATIO\nmutation_ratio = 0.1  # MUTATION RATIO\nmutation_sigma = 1.0  # MUTATION GAUSSIAN SIGMA\nmax_turns = 600  # MAX PLAY TURNS PER TRIAL\nneural_functions = [identity]  # NEURAL FUNCTION VECTOR\nsensor_method = \"default\"\n\n# PRE-PROCESSING\nkeep_individuals = int(keep_ratio * Npop)\nNw = 0\nfor i in range(len(Net_struct) - 1):\n    nin = Net_struct[i]\n    nout = Net_struct[i + 1]\n    Nw += (nin + 1) * nout\n# all_weights = np.random.normal(loc=0.0, scale=1.0, size=(Npop, Nw))\nall_weights = (np.random.rand(Npop, Nw) - 0.5) * 2.0\n\nagents = []\nfor agent_id in range(Npop):\n    weights = all_weights[agent_id]\n    agent = NeuralAgent(\n        weights=weights, structure=Net_struct, neural_functions=neural_functions\n    )\n    agents.append(agent)\nagent_functions = [agent.get_caller() for agent in agents]\nfunc = agent_functions[0]\ntotal_generations = 1\ngeneration_store = []\nbest_score_store = []\n\n\n\n# DATA STORAGE\nsnake4 = FastSnake(\n    Nrow=12, Ncol=12, record_turns=False, recorded_sensors_method=sensor_method\n)\nscores = np.zeros(Npop)\nturns = np.zeros(Npop)\ntries_scores = np.zeros(Ntries)\ntries_turns = np.zeros(Ntries)\nnew_all_weights = np.zeros_like(all_weights)\nturn_ids = np.array([-1.0, 0.0, 1.0])\nfor generation in range(Ngen):\n    print(f\"Generation: {total_generations}\")\n    generation_store.append(total_generations)\n    scores[:] = 0.0\n    turns[:] = 0.0\n    for agent_id in range(Npop):\n        # np.random.seed(0)\n        tries_scores[:] = 0.0\n        tries_turns[:] = 0.0\n        agent_func = agent_functions[agent_id]\n        for trial in range(Ntries):\n            snake4.reset()\n            Ncol = snake4.Ncol\n            Nrow = snake4.Nrow\n            snake4.fruit_position = (Nrow - 2) * Ncol + Ncol - 2\n            turn = 0\n            while snake4.status == 0:\n                sensors = snake4.sensors(method=sensor_method)\n                my_choice = turn_ids[argMax(agent_func(sensors))]\n                snake4.turn(my_choice)\n                turn += 1\n                if turn >= max_turns:\n                    break\n            tries_scores[trial] = snake4.score\n            tries_turns[trial] = turn\n        scores[agent_id] = tries_scores.mean()\n        turns[agent_id] = tries_turns.mean()\n    perf = scores * 100 - turns\n    order = np.argsort(perf)[::-1]\n    new_all_weights[:] = 0.0\n    # SELECTION\n    new_all_weights[:keep_individuals] = all_weights[order][:keep_individuals]\n    # HYBRIDATION\n    keep_range = np.arange(keep_individuals)\n    for indiv in range(keep_individuals, Npop):\n        parents = np.random.choice(keep_range, 2)\n        while parents[1] == parents[0]:\n            parents = np.random.choice(keep_range, 2)\n        pw = np.random.rand(Nw)\n        new_all_weights[indiv] = (\n            new_all_weights[parents[0]] * pw + (1.0 - pw) * new_all_weights[parents[1]]\n        )\n\n        # MUTATION:\n        if np.random.rand() <= mutation_ratio:\n            # mutation_loc = np.random.randint(Nw)\n            new_all_weights[indiv] *= np.random.normal(\n                loc=1.0, scale=mutation_sigma, size=Nw\n            )\n    total_generations += 1\n    all_weights[:] = new_all_weights\n\n    data = pd.DataFrame(\n        {\"score\": scores[order], \"turns\": turns[order], \"perf\": perf[order]}\n    )  # .sort_values( \"perf\", ascending=False    )\n    print(data.head(5))\n    print(f\"=> best score = {scores.max()}\")\n    best_score_store.append(data.iloc[0].score)\nprint(\"FINISHED\")\nplt.figure(\"Snake at the gym !\")\nplt.clf()\nplt.plot(generation_store, best_score_store, \"or-\")\nplt.xlabel(\"Generation\")\nplt.ylabel(\"Best Score\")\nplt.grid()\nplt.show()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nsnake5 = FastSnake(\n    Nrow=12, Ncol=12, record_turns=True, recorded_sensors_method=sensor_method\n)\n# np.random.seed(0)\n# weights = all_weights[0]  # BEST AGENT\nbest_agent_func = agent_functions[0]\nturn_ids = np.array([-1.0, 0.0, 1.0])\nnp.random.seed(0)\n\n\ndef updatefig(*args):\n    if snake.status == 0:\n        sensors = snake5.sensors(method=sensor_method)\n        my_choice = turn_ids[argMax(best_agent_func(sensors))]\n\n        snake5.turn(my_choice)\n        im2.set_array(snake5.grid)\n        score = snake5.score\n        iteration = snake5.iteration\n        title2.set_text(f\"Score = {score} Iteration = {iteration}\")\n\n    else:\n        title2.set_text(f\"Youd died with score = {score}\")\n    return im2\n\n\nscore = 0\nfig2, ax2 = plt.subplots()\nax2.axis(\"off\")\ntitle2 = ax2.set_title(f\"Score = {score}\", animated=True)\nim2 = plt.imshow(snake5.grid, interpolation=\"nearest\", animated=True)\nanim = animation.FuncAnimation(fig2, updatefig, frames=1000, interval=30, blit=True)\n# plt.show()\nplt.close()\nanim\n\n\n\nturns = snake5.recorded_turns\nsensors = np.array(snake5.recorded_sensors)\n\nout = {\n    \"turn\": turns,\n}\nfor i, s in enumerate(sensors.T):\n    out[f\"s{i}\"] = s\n\ndata = pd.DataFrame(out)\ndata.iloc[-10:]\n\n\n\n","type":"content","url":"/genetic-snake-practical-work#genetic-neural-network-agent","position":29},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Question 4","lvl2":"Genetic Neural Network agent"},"type":"lvl3","url":"/genetic-snake-practical-work#question-4","position":30},{"hierarchy":{"lvl1":"Reinforcement learning on snake with a genetic neural network","lvl3":"Question 4","lvl2":"Genetic Neural Network agent"},"content":"Play with the neural agent and find a performance formulation to get the highest score in less than 1000 turns.","type":"content","url":"/genetic-snake-practical-work#question-4","position":31},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material-3","position":0},{"hierarchy":{"lvl1":"Support material"},"content":"from IPython.display import YouTubeVideo\n\n\n\n","type":"content","url":"/support-material-3","position":1},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material-3#support-material","position":2},{"hierarchy":{"lvl1":"Support material"},"content":"","type":"content","url":"/support-material-3#support-material","position":3},{"hierarchy":{"lvl1":"Support material","lvl2":"Machine learning"},"type":"lvl2","url":"/support-material-3#machine-learning","position":4},{"hierarchy":{"lvl1":"Support material","lvl2":"Machine learning"},"content":"Machine learning is a type of artificial intelligence that allows machines to learn and improve their performance on a task based on data. The basic idea is to use algorithms to automatically identify patterns in data and use those patterns to make predictions or decisions.\n\nThe process typically involves three main steps:\n\nData preparation: This involves collecting, cleaning, and organizing data for use in training and testing machine learning models.\n\nModel training: In this step, a machine learning algorithm is applied to the data to create a model that can make predictions or decisions based on new data.\n\nModel evaluation: Once a model has been created, it is tested on a separate set of data to evaluate its accuracy and performance.\n\nThere are many different types of machine learning algorithms, including supervised learning, unsupervised learning, and reinforcement learning. Supervised learning involves training a model using labeled data, while unsupervised learning involves finding patterns in unlabeled data. Reinforcement learning involves training a model through trial and error based on rewards and punishments.\n\nMachine learning is used in a wide variety of applications, from predicting customer behavior and optimizing supply chain management to detecting fraud and diagnosing diseases.\nFor more general information, please read the \n\nWikipedia page on this topic\n\nYou can also consult the following documents:\n\nThe excellent documentation of the Python module \n\nScikit-learn.\n\nOr the following videos.\n\nYouTubeVideo(\"trWrEWfhTVg\")\n\n\n\nYouTubeVideo(\"xuBzQ38DNhE\")\n\n\n\n","type":"content","url":"/support-material-3#machine-learning","position":5},{"hierarchy":{"lvl1":"Support material","lvl2":"Neural networks"},"type":"lvl2","url":"/support-material-3#neural-networks","position":6},{"hierarchy":{"lvl1":"Support material","lvl2":"Neural networks"},"content":"Neural networks are a type of machine learning algorithm that are inspired by the structure and function of the human brain. They are used to model complex relationships between inputs and outputs in order to make predictions or decisions.\n\nThe basic idea behind neural networks is to simulate the behavior of interconnected neurons in the brain. A neural network is made up of layers of artificial neurons, each of which takes in one or more inputs, performs a mathematical computation, and passes the result to the next layer of neurons.\n\nThe first layer of neurons is called the input layer, and it receives input data. The last layer of neurons is called the output layer, and it produces the final output of the network. There may be one or more hidden layers of neurons in between the input and output layers, which perform intermediate computations.\n\nDuring training, the weights and biases of the neurons are adjusted so that the network can learn to make accurate predictions or decisions based on the input data. This is done by comparing the output of the network to the desired output, and using an optimization algorithm to adjust the weights and biases to minimize the difference between the two.\n\nThere are many different types of neural networks, each with its own architecture and learning algorithm. Some common types include feedforward neural networks, recurrent neural networks, and convolutional neural networks. Neural networks are used in a wide range of applications, from image and speech recognition to natural language processing and autonomous vehicles.\n\nYouTubeVideo(\"aircAruvnKk\")\n\n\n\nHere an explication from a French Youtube video maker\n\nYouTubeVideo(\"XUFLq6dKQok\")\n\n","type":"content","url":"/support-material-3#neural-networks","position":7},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises-3","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"In this section, we propose quick exercises that can typically be done in an hour and a half.:\n\nSimple pendulum (duration: 1.5 h): introductory exercise that proposes to model a simple pendulum and to put into practice the notions available in the course. The oscillatory or non-oscillatory form of the solutions will be discussed and the phase plane will be used to better understand these differences.\n\nDriven Harmonic Oscillator (duration: 1.5 h): In this introductory exercise, you will put into practice the notions seen in class in the case of a driven harmonic oscillator. The presence of a damping and an excitation leads to the presence of a unique orbit which is different from the case of the simple pendulum.","type":"content","url":"/exercises-3","position":1},{"hierarchy":{"lvl1":"Exercices","lvl2":"Practical work"},"type":"lvl2","url":"/exercises-3#practical-work","position":2},{"hierarchy":{"lvl1":"Exercices","lvl2":"Practical work"},"content":"In this section, we propose longer exercises that can be done without assistance, typically in 4 hours.\n\nVibrational energy harvesting using a Duffing oscillator (duration: 4 h): The Duffing oscillator is a non-linear oscillator due to its position-dependent stiffness. It is one of the simplest oscillators capable of exhibiting chaos. In this exercise, you will be led to think about the notions of orbit, sub harmonic, chaos and Poincaré section.","type":"content","url":"/exercises-3#practical-work","position":3},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator"},"type":"lvl1","url":"/duffing-oscillator","position":0},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator"},"content":"%matplotlib widget\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\nimport pandas as pd\nfrom math import pi, sin, cos\n\n\n\n","type":"content","url":"/duffing-oscillator","position":1},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator"},"type":"lvl1","url":"/duffing-oscillator#ode-practical-work-duffing-oscillator","position":2},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator"},"content":"Author: Ludovic Charleux (\n\nludovic​.charleux@univ​-smb​.fr)\n\nRequired files\n\nIn order to display figures properly, please download these images from \n\nHuguet et al., 2019:\n\nhuguet​_experimental​_setup​.png\n\nhuguet​_model​_design​.png\n\nAnd put it in your working directory along with this notebook. This tutorial is inspired by the PhD work of Thomas Huguet, in particular the article \n\nHuguet et al., 2019 available \n\nhere. Download it and read it to better understand the context of this exercise.\n\n","type":"content","url":"/duffing-oscillator#ode-practical-work-duffing-oscillator","position":3},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Introduction"},"type":"lvl2","url":"/duffing-oscillator#introduction","position":4},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Introduction"},"content":"The \n\nDuffing oscillator  is a one-degree-of-freedom oscillator which, unlike a harmonic oscillator, has a non-linearity in its stiffness function. In its most general form, its differential equation can be written as:\\ddot x + \\delta \\dot x + \\alpha x  +  \\beta x^3 = A \\sin (\\omega_d t)\n\nThe non-linearity comes from the \\beta x^3 term. In this tutorial, we are going to work on a Duffing oscillator used in a practical purpose to recover vibratory energy in order to power autonomous communicating sensors. We are going to use the \n\nPhD thesis of Thomas Huguet from the INSA Lyon and the University of Savoie Mont Blanc (defended in 2018).\nIn the context of his article \n\nHuguet et al. (2019), the choice of a Duffing oscillator is justified by its ability to efficiently recover energy over a broader frequency band than an equivalent harmonic oscillator.\nWe will discuss some very interesting aspects of the Duffing oscillator, including:\n\nIts ability to have several different solutions for the same excitation.\n\nIts ability to respond chaotically in some cases.\n\nThe Duffing oscillator that we will model is mechanically bistable, it is realized using the principle described on the diagram below (from  \n\nHuguet et al., 2019):\n\nA beam with a mass in its center is compressed to buckling.\nIt is then excited by means of a shaker which represents the vibrations present in the environment.\nAn electrical extraction circuit is present but will not be modeled in this tutorial to simplify your task.\nThe system has been manufactured and tested in the laboratory and is shown in the figure below (from  \n\nHuguet et al., 2019):\n\nThe differential equation associated with this system is as follows:\\ddot x + \\dfrac{\\omega_0^2}{2}\\left(\\dfrac{x^2}{x_{w}^2} - 1\\right)x + \\dfrac{\\omega_0}{Q} \\dot x = A_d \\sin \\left( \\omega_d t \\right)\n\nWhere:\n\nThe position of the mass, its speed and acceleration are respectively noted x, \\dot x and \\ddot x.\n\nThe stable equilibrium position, or well position,  is noted \\pm x_{w} (noted x_0 on the figure above).\n\nThe resonance frequency at the bottom of the well is noted \\omega_0.\n\nThe quality factor is noted Q.\n\nThe excitation is defined by its amplitude A_d and its pulsation \\omega_d = 2 \\pi f_d where f_d is its frequency.\n\nNote: In the configuration studied in the paper, an additional equation describes the behavior of the electrical energy extraction circuit. To simplify our task, it is not modeled in this example. You can add it if you wish, based on the article and by integrating the voltage v to your vector X.\n\nThe numerical values of these parameters are defined here:\n\nxw = 0.5e-3  # meters\nw0 = 121.0  # radians per second\nQ = 87.0  # dimensionless\nfd = 50.0  # Hertz\nwd = 2.0 * pi * fd\nAd = 2.5  # meters per second squared\n\n\n\n","type":"content","url":"/duffing-oscillator#introduction","position":5},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 1: ODE reformulation"},"type":"lvl2","url":"/duffing-oscillator#part-1-ode-reformulation","position":6},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 1: ODE reformulation"},"content":"First, you are asked to reformulate the ODE to first order using the standard form seen in the course:\\dot X = f(X, t)\n\nWith:X = \\begin{bmatrix}\nx \\\\\n\\dot x\n\\end{bmatrix}\n\nAnd, as a consequence:\\dot X = \\begin{bmatrix}\n\\dot x \\\\\n\\ddot x\n\\end{bmatrix}\n\n# COMPLETE THIS CELL\n\n\ndef f(X, t):\n    \"\"\"\n    Duffing equation.\n    \"\"\"\n    x, dotx = X\n    dotX = np.zeros(2)\n    # COMPLETE\n    # dotX[0] =\n    # dotX[1] =\n    return dotX\n\n\n\n","type":"content","url":"/duffing-oscillator#part-1-ode-reformulation","position":7},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 2: Time integration"},"type":"lvl2","url":"/duffing-oscillator#part-2-time-integration","position":8},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 2: Time integration"},"content":"","type":"content","url":"/duffing-oscillator#part-2-time-integration","position":9},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Integration","lvl2":"Part 2: Time integration"},"type":"lvl3","url":"/duffing-oscillator#integration","position":10},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Integration","lvl2":"Part 2: Time integration"},"content":"Integrate the equation with respect to time from a point X_0 of your choice during N_T=1000 periods with N_F=60 time steps per period:\n\n# COMPLETE THIS CELL\n\n# SETUP\nNT = 1000  # NUMBER OF EXCITATION PERIODS\nNF = 180  # FRAMES PER EXCITATION PERIODS\nTd = fd**-1  # EXCITATION FREQUENCY\ndt = Td / NF  # TIME STEP\n# t =\nX0 = np.array([0.0, 0.0])  # CHANGE THE VALUES TO YOUR LIKING\n# sol = # SOLVE THE ODE\n# x =\n# dotx =\n\n\n\n","type":"content","url":"/duffing-oscillator#integration","position":11},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Amplitude vs. time","lvl2":"Part 2: Time integration"},"type":"lvl3","url":"/duffing-oscillator#amplitude-vs-time","position":12},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Amplitude vs. time","lvl2":"Part 2: Time integration"},"content":"Plot the resulting position vs time (t, x):\n\n# xmax = x.max() / xw\n# xmin = x.min() / xw\n# xspan = xmax - xmin\n# xlim = xmin - .1 * xspan, xmax +.1 * xspan\n\nfig = plt.figure(figsize=(10, 6))\nax1 = fig.add_subplot(1, 2, 1)\nplt.title(\"Whole solution\")\n# plt.plot(t/Td, x/xw, \"r-\", label = \"Whole solution\")\n# plt.plot(t[-5*NF:]/Td, x[-5*NF:]/xw, \"b-\", label = \"Last 5 periods\")\nplt.grid()\nplt.legend()\nplt.xlabel(\"Time, $t/T_d$\")\nplt.ylabel(\"Position $x/x_{w}$\")\n# plt.ylim(*xlim)\nax2 = fig.add_subplot(1, 2, 2)\nplt.title(\"Steady state\")\n# plt.plot(t[-5*NF:]/Td, x[-5*NF:]/xw, \"b-\", label = \"Last 5 periods\")\nplt.grid()\nplt.legend()\n# plt.ylim(*xlim)\nplt.xlabel(\"Time, $t/T_d$\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/duffing-oscillator#amplitude-vs-time","position":13},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Phase plane","lvl2":"Part 2: Time integration"},"type":"lvl3","url":"/duffing-oscillator#phase-plane","position":14},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl3":"Phase plane","lvl2":"Part 2: Time integration"},"content":"Plot the resulting trajectory in the phase plane (x, \\dot x):\n\nplt.figure()\n# plt.plot(x/xw, dotx/(xw*w0), \"r-\", label = \"Transient regime\")\n# plt.plot(x[-5*NF:]/xw, dotx[-5*NF:]/(xw*w0), \"b-\", label = \"Steady state\")\nplt.grid()\nplt.xlabel(\"Position $x/x_{w}$\")\nplt.ylabel(\"Speed, $\\dot x / {\\omega_d x_{w}}$\")\nplt.show()\n\n\n\n\n\nDepending on your starting point, the trajectory may lead to a different steady state regime.\n\nQuestions:\n\nInterpret the graphs obtained. In particular, emphasize the differences between transient and steady-state conditions. Does the latter depend on the same frequency as the acceleration imposed on the system? Is there more than one steady state? If so, how can you identify them all?\n\nPropose ways to extract information on the dynamic behavior of this system.\n\n","type":"content","url":"/duffing-oscillator#phase-plane","position":15},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 3: Poincaré sections and attractors"},"type":"lvl2","url":"/duffing-oscillator#part-3-poincar-sections-and-attractors","position":16},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 3: Poincaré sections and attractors"},"content":"The \n\nPoincaré section is a tool developed by Henri Poincaré to observe and analyze the behavior of an integral curve.\nIn the present case, we propose to look at a particular form of Poincaré section by plotting only the positions of the system in the phase space that correspond to whole excitation periods, i.e. t = 0. \\mbox{ mod } Td.\nThink of a way to plot these points and put it in place.\n\nRemark: have a look at the \n\nNumpy slicing tutorial\n\n# POINCARE SECTION\n# xp = # COMPLETE\n# dotx =  # COMPLETE\n\nplt.figure()\n# plt.scatter(xp/xw, dotxp/(xw*w0), marker=\"o\", s = 5, color = \"r\", label = \"Poincaré Section\")\n# plt.scatter(xp[-5:]/xw, dotxp[-5:]/(xw*w0), marker=\"o\", s = 30, color = \"b\", label = \"Attractors\")\nplt.grid()\n# plt.legend()\nplt.xlabel(\"Position $x/x_{w}$\")\nplt.ylabel(\"Speed, $\\dot x / {\\omega_d x_{w}}$\")\nplt.show()\n# plt.close(\"all\")\n\n\n\n\n\nAt this point, you may have noticed that the Poincaré section indicates that the trajectory of the system in the phase plane is a convergence to one (or more) particular points called attractors. Change the values of X_0 and try to find different attractors.\n\nHint: try these start points\n\nX0 = np.array([-4.0 * xw, 3.0 * xw * w0])\nX0 = np.array([-4.0 * xw, 5.0 * xw * w0])\nX0 = np.array([-3.0 * xw, 4.0 * xw * w0])\nX0 = np.array([-3.0 * xw, 5.0 * xw * w0])\nX0 = np.array([-7.0 * xw, 20.0 * xw * w0])\n\n\n\nNote: write down a list of the attractors that you have found, you will used them in the next part.\n\nattractors = []  # A LIST OF ATTRACTORS\n\n\n\nQuestions\n\nHow do you explain that the Poincaré section seems to converge to several points in some cases? Feel free to consult \n\nThomas Huguet’s article.\n\nHow can we classify the attractors?\n\n","type":"content","url":"/duffing-oscillator#part-3-poincar-sections-and-attractors","position":17},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 4: Orbits"},"type":"lvl2","url":"/duffing-oscillator#part-4-orbits","position":18},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 4: Orbits"},"content":"In the previous section, you observed that the Poincaré sections in the phase plane converge to particular points called attractors. The trajectory of an attractor in the phase plane is called an orbit.Draw these trajectories for all the attractors you found.\n\n\n\n\n\nQuestions:\n\nInterpret how these orbits are assembled in layers.\n\n","type":"content","url":"/duffing-oscillator#part-4-orbits","position":19},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 3: Chaos and strange attractor"},"type":"lvl2","url":"/duffing-oscillator#part-3-chaos-and-strange-attractor","position":20},{"hierarchy":{"lvl1":"Vibrational energy harvesting using a Duffing oscillator","lvl2":"Part 3: Chaos and strange attractor"},"content":"We now propose to work with a different excitation frequency. In this case, you will observe that the Poincaré section does not always converge to a point, it can also converge to a surface called a \n\nstrange attractor. Make this strange attractor obvious by drawing the Poincaré sections. What do you observe ?\n\nNT = 10000  # NUMBER OF EXCITATION PERIODS\nNF = 8  # FRAMES PER EXCITATION PERIODS\nfd = 25.0  # Hertz\nomegad = 2.0 * pi * fd\nTd = fd**-1  # EXCITATION FREQUENCY\ndt = Td / NF  # TIME STEP\n\n\n# CODE HERE\n\n\n\nplt.figure()\n# plt.scatter(xp/xw, dotxp/(xw*w0), marker=\"o\", s = 5, color = \"r\")\nplt.grid()\nplt.xlabel(\"Position $x/x_{w}$\")\nplt.ylabel(\"Speed, $\\dot x / {\\omega_d x_{w}}$\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/duffing-oscillator#part-3-chaos-and-strange-attractor","position":21},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator"},"type":"lvl1","url":"/harmonic-oscillator","position":0},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator"},"content":"# IF USING JUPYTER NOTEBOOK:\n# %matplotlib notebook\n# IF USING JUPYTER LAB:\n%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\nfrom scipy.integrate import odeint\n\n\n\n","type":"content","url":"/harmonic-oscillator","position":1},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator"},"type":"lvl1","url":"/harmonic-oscillator#ode-tutorial-driven-harmonic-oscillator","position":2},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator"},"content":"Author: Ludovic Charleux (\n\nludovic​.charleux@univ​-smb​.fr)\n\nIn this example, you will simulate an harmonic oscillator and compare the numerical solution to the closed form one.","type":"content","url":"/harmonic-oscillator#ode-tutorial-driven-harmonic-oscillator","position":3},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Theory"},"type":"lvl2","url":"/harmonic-oscillator#theory","position":4},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Theory"},"content":"Read about the theory of harmonic oscillators on \n\nWikipedia","type":"content","url":"/harmonic-oscillator#theory","position":5},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl3":"Mechanical oscillator","lvl2":"Theory"},"type":"lvl3","url":"/harmonic-oscillator#mechanical-oscillator","position":6},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl3":"Mechanical oscillator","lvl2":"Theory"},"content":"The case of the one dimensional mechanical oscillator leads to the following equation:m \\ddot x + \\mu \\dot x + k x = m \\ddot x_d\n\nWhere:\n\nx is the position,\n\n\\dot x and \\ddot x are respectively the speed and acceleration,\n\nm is the mass,\n\n\\mu the\n\nk the stiffness,\n\nand \\ddot x_d the driving acceleration which is null if the oscillator is free.","type":"content","url":"/harmonic-oscillator#mechanical-oscillator","position":7},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl3":"Canonical equation","lvl2":"Theory"},"type":"lvl3","url":"/harmonic-oscillator#canonical-equation","position":8},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl3":"Canonical equation","lvl2":"Theory"},"content":"Most 1D oscilators follow the same canonical equation:\\ddot x + 2 \\zeta \\omega_0 \\dot x + \\omega_0^2 x = \\ddot x_d\n\nWhere:\n\n\\omega_0 is the undamped pulsation,\n\n\\zeta is damping ratio,\n\n\\ddot x_d = a_d\\sin(\\omega_d t) is the imposed acceleration.\n\nIn the case of the mechanical oscillator:\\omega_0 = \\sqrt{\\dfrac{k}{m}}\\zeta = \\dfrac{\\mu}{2\\sqrt{mk}}\n\nomega0 = 2.0 * np.pi * 1.0\nzeta = 0.1\nad = 1.0\nomegad = 2.0 * np.pi * 1.2\n\n\n\n","type":"content","url":"/harmonic-oscillator#canonical-equation","position":9},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 1: Coding"},"type":"lvl2","url":"/harmonic-oscillator#part-1-coding","position":10},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 1: Coding"},"content":"First, you need to code: the harmonic oscillator oscillator using the standarde ODE formulation:\\dot X = f(X, t)\n\ndef f(X, t):\n    \"\"\"\n    Driven Harmonic oscillator.\n    \"\"\"\n    return\n\n\n\n","type":"content","url":"/harmonic-oscillator#part-1-coding","position":11},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 2: Solving"},"type":"lvl2","url":"/harmonic-oscillator#part-2-solving","position":12},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 2: Solving"},"content":"Solve the ODE using odeint and plot it.\n\n\n\n\n\n","type":"content","url":"/harmonic-oscillator#part-2-solving","position":13},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 3: Steady state amplitude"},"type":"lvl2","url":"/harmonic-oscillator#part-3-steady-state-amplitude","position":14},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 3: Steady state amplitude"},"content":"Determine the steady state amplitude a(\\omega_d) of the oscillator.\n\n\n\n\n\n","type":"content","url":"/harmonic-oscillator#part-3-steady-state-amplitude","position":15},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 4: Amplitude vs. drive pulsation"},"type":"lvl2","url":"/harmonic-oscillator#part-4-amplitude-vs-drive-pulsation","position":16},{"hierarchy":{"lvl1":"Driven Harmonic Oscillator","lvl2":"Part 4: Amplitude vs. drive pulsation"},"content":"Plot the evolution of the amplitude of the driven oscillator and compare it with the theory.","type":"content","url":"/harmonic-oscillator#part-4-amplitude-vs-drive-pulsation","position":17},{"hierarchy":{"lvl1":"Simple pendulum"},"type":"lvl1","url":"/simple-pendulum","position":0},{"hierarchy":{"lvl1":"Simple pendulum"},"content":"# IF USING JUPYTER NOTEBOOK:\n# %matplotlib notebook\n# IF USING JUPYTER LAB:\n%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\nfrom scipy.integrate import odeint\n\n\n\n","type":"content","url":"/simple-pendulum","position":1},{"hierarchy":{"lvl1":"Simple pendulum"},"type":"lvl1","url":"/simple-pendulum#ode-tutorial-simple-pendulum","position":2},{"hierarchy":{"lvl1":"Simple pendulum"},"content":"Author: Ludovic Charleux (\n\nludovic​.charleux@univ​-smb​.fr)","type":"content","url":"/simple-pendulum#ode-tutorial-simple-pendulum","position":3},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Background"},"type":"lvl2","url":"/simple-pendulum#background","position":4},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Background"},"content":"This tutorial aims to model and simulate the oscillations of a simple pendulum. A representation is given below (source: \n\nWikipedia).\n\nThe pendulum consists of a point mass m located at the point M attached to a rigid arm considered without mass. The length of the arm is noted L. This arm is articulated with respect to a frame considered as an inertial reference frame. The angle between the arm and the vertical direction is noted \\theta. A simple modeling using dynamics leads to :m\\vec A(M/0) = \\vec P + \\vec T\n\nWhere:\n\n\\vec A(M/0) is the acceleration of the mass,\n\n\\vec P if the weight of the mass,\n\n\\vec T if the reaction force of the arm.\n\nA projection of this equation along the direction perpendicular to the arm gives a more simple equation:\\ddot \\theta = -\\dfrac{g}{L} \\sin \\theta\n\nThis equation is a non linear ODE of the second order whose exact solution is not known.  It is however possible to assume that \\theta is small enough to write that \\sin \\theta \\approx \\theta. In this case, the equation comes down to the one of a free and undamped harmonic oscillator treated in the theoretical part. The object of this tutorial is to solve this problem by a numerical approach in a general way without simplifying assumptions.\n\nL = 1.0  # m\ng = 9.81  # m/s**2\n\n\n\n","type":"content","url":"/simple-pendulum#background","position":5},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 1: ODE reformulation"},"type":"lvl2","url":"/simple-pendulum#part-1-ode-reformulation","position":6},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 1: ODE reformulation"},"content":"This problem can be reformulated to match the standard formulation \\dot X = f(X, t):X = \\begin{bmatrix} \\theta \\\\ \\dot \\theta \\end{bmatrix}\n= \\begin{bmatrix} x_0 \\\\ x_1 \\end{bmatrix}\\dot X = \\begin{bmatrix} x_1 \\\\ -\\dfrac{g}{L} \\sin x_0 \\end{bmatrix} = f(X, t)\n\nWrite the function f in Python:\n\ndef f(X, t):\n    \"\"\"\n    The simple pendulum's ODE\n    \"\"\"\n    # CODE HERE !\n    return\n\n\n\n","type":"content","url":"/simple-pendulum#part-1-ode-reformulation","position":7},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 2: solver validation at small angles"},"type":"lvl2","url":"/simple-pendulum#part-2-solver-validation-at-small-angles","position":8},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 2: solver validation at small angles"},"content":"In this first part, we want to validate the operation of the numerical solvers by comparing their results to a known exact solution. To do so, we will focus on the case of the simple pendulum oscillating at small angles. In this case, the sine can be approximated by \\sin \\theta \\approx \\theta and the equation of the pendulum can be reduced to that of a harmonic oscillator. The exact solution is then:x(t) = \\theta_0 \\cos(\\omega_0 t)\n\nWith:\n\nX_0 = [\\theta_0, 0]^T\n\n\\omega_0 = \\sqrt{g/L}\n\nSolve the problem with Euler, RK4 and ODEint integrators and compare the results with the closed form solution. First assume that the pendulum is released with no speed (\\dot \\theta = 0 ^o/s) at \\theta = 1 ^o. The time discretization will be as follows:\n\nduration: from t_a = 0 s to t_b = 10 s.\n\ntime step: dt = 1. \\times 10^{-2} s.\n\ndef Euler(func, X0, t):\n    \"\"\"\n    Euler integrator.\n    \"\"\"\n    dt = t[1] - t[0]\n    nt = len(t)\n    X = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt - 1):\n        X[i + 1] = X[i] + func(X[i], t[i]) * dt\n    return X\n\n\ndef RK4(func, X0, t):\n    \"\"\"\n    Runge and Kutta 4 integrator.\n    \"\"\"\n    dt = t[1] - t[0]\n    nt = len(t)\n    X = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt - 1):\n        k1 = func(X[i], t[i])\n        k2 = func(X[i] + dt / 2.0 * k1, t[i] + dt / 2.0)\n        k3 = func(X[i] + dt / 2.0 * k2, t[i] + dt / 2.0)\n        k4 = func(X[i] + dt * k3, t[i] + dt)\n        X[i + 1] = X[i] + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    return X\n\n\n# ODEint is preloaded.\n\n\n\n# Define the time vector t and the initial conditions X0\nta = 0.0\ntb = 10.0\n# CODE HERE\nt = []  # REPLACE\n\n\n\ntheta = []  # REPLACE WITH YOUR SOLUTION\n\nplt.figure()\nplt.plot(t, np.degrees(theta))\nplt.xlabel(\"Time, $t$\")\nplt.ylabel(r\"Angular position, $\\theta$ [$^o$]\")\nplt.grid()\n\n\n\n","type":"content","url":"/simple-pendulum#part-2-solver-validation-at-small-angles","position":9},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 3: Anharmonic oscillations at larger energies"},"type":"lvl2","url":"/simple-pendulum#part-3-anharmonic-oscillations-at-larger-energies","position":10},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 3: Anharmonic oscillations at larger energies"},"content":"In what follows, we work only with one of the solvers that has been sufficiently accurate in the previous section. We are interested in the operation of the pendulum at higher energy. First, increase the initial angle \\theta_0 to 179^o and add an initial velocity. What do you observe about the shape of the curves (time, position) ?\n\n# CODE HERE\n\n\n\ntheta = []  # REPLACE WITH YOUR SOLUTION\n\nplt.figure(\"High energy\")\nplt.plot(t, np.degrees(theta))\nplt.xlabel(\"Time, $t$\")\nplt.ylabel(r\"Angular position, $\\theta$ [$^o$]\")\nplt.grid()\n\n\n\n","type":"content","url":"/simple-pendulum#part-3-anharmonic-oscillations-at-larger-energies","position":11},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 4 : Phase space"},"type":"lvl2","url":"/simple-pendulum#part-4-phase-space","position":12},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 4 : Phase space"},"content":"For several initial conditions treated previously, draw the trajectory (integral curve) in the (\\theta, \\dot \\theta) phase plane. What remarkable points do you observe ?\n\ntheta = []  # REPLACE\ndottheta = []  # REPLACE\n\nplt.figure(\"Phase space\")\nplt.plot(np.degrees(theta), np.degrees(dottheta))\nplt.xlabel(r\"Angular position, $\\theta$ [$^o$]\")\nplt.xlabel(r\"Angular speed, $\\dot\\theta$ [$^o$]\")\nplt.grid()\n\n\n\n","type":"content","url":"/simple-pendulum#part-4-phase-space","position":13},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 5: Conclusions"},"type":"lvl2","url":"/simple-pendulum#part-5-conclusions","position":14},{"hierarchy":{"lvl1":"Simple pendulum","lvl2":"Part 5: Conclusions"},"content":"Conclude on your observations on the following points: quality of the numerical solutions, shape of the integral curves, interest of the various representations used.\n\n# ...\n\n","type":"content","url":"/simple-pendulum#part-5-conclusions","position":15},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock"},"type":"lvl1","url":"/badminton","position":0},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock"},"content":"%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport IPython\nfrom scipy import integrate\n\n\n\n","type":"content","url":"/badminton","position":1},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Data collection"},"type":"lvl2","url":"/badminton#data-collection","position":2},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Data collection"},"content":"\n\n\n\nFurther reading:\n\nBadminton physics: \n\nhttp://​www​.worldbadminton​.com​/reference​/documents​/5084354​.pdf\n\nDrag coefficient: \n\nDrag coefficient\n\nSimulation inputs:\n\nv0 = 493.0 / 3.6  # Initial velocity [m/s]\nA = 4.0e-3  # Shuttlecock cross area [m**2]\ncx = 0.62  # Drag coefficient []\nm = 4.0e-2  # Shuttlecock mass [kg]\nrho = 1.225  # Air density [kg/m**3]\ng = 9.81  # Gravity [m/s**2]\n\n\n\n","type":"content","url":"/badminton#data-collection","position":3},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Can we simulate the trajectory ?"},"type":"lvl2","url":"/badminton#can-we-simulate-the-trajectory","position":4},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Can we simulate the trajectory ?"},"content":"","type":"content","url":"/badminton#can-we-simulate-the-trajectory","position":5},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl3":"Newton’s second law:","lvl2":"Can we simulate the trajectory ?"},"type":"lvl3","url":"/badminton#newtons-second-law","position":6},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl3":"Newton’s second law:","lvl2":"Can we simulate the trajectory ?"},"content":"m \\vec{A}(M/R) = -mg \\vec y -\\frac{1}{2} \\rho V^2 A c_x \\vec T\n\ndef derivative(X, t):\n    \"\"\"\n    Target ODE: Newton's second law\n    \"\"\"\n    x, y, vx, vy = X\n    v = (vx**2 + vy**2) ** 0.5\n    Tx, Ty = vx / v, vy / v\n    ax = -0.5 * rho * v**2 * A * cx * Tx / m\n    ay = -0.5 * rho * v**2 * A * cx * Ty / m - g\n    return np.array([vx, vy, ax, ay])\n\n\nx0, y0 = 0.0, 0.0\ntheta0 = 45.0\nX0 = [x0, y0, v0 * np.cos(np.radians(theta0)), v0 * np.sin(np.radians(theta0))]\nt = np.linspace(0.0, 10.0, 200)\nsol = integrate.odeint(derivative, X0, t)\nout = pd.DataFrame(sol, columns=[\"x\", \"y\", \"vx\", \"vy\"])\nout.head()\n\n\n\nplt.figure()\nplt.plot(out.x, out.y)\nplt.grid()\nplt.ylim(0.0, 50.0)\nplt.xlabel(\"Position, $x$\")\nplt.ylabel(\"Position, $y$\")\nplt.show()\n\n\n\nthetas = [0.0, 10.0, 15.0, 20.0, 30.0, 45.0, 60.0, 80.0, 85.0]\nplt.figure()\n\nfor theta0 in thetas:\n    x0, y0 = 0.0, 3.0\n    X0 = [x0, y0, v0 * np.cos(np.radians(theta0)), v0 * np.sin(np.radians(theta0))]\n    t = np.linspace(0.0, 10.0, 1000)\n    sol = integrate.odeint(derivative, X0, t)\n    out = pd.DataFrame(sol, columns=[\"x\", \"y\", \"vx\", \"vy\"])\n    out[\"t\"] = t\n    plt.plot(out.x, out.y, label=r\"$\\theta_0 = $\" + \"{0}\".format(theta0))\nplt.legend()\nplt.grid()\nplt.ylim(0.0, 50.0)\nplt.xlabel(\"Position, $x$\")\nplt.ylabel(\"Position, $y$\")\nplt.show()\n\n\n\n","type":"content","url":"/badminton#newtons-second-law","position":7},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Range as a function of \\theta"},"type":"lvl2","url":"/badminton#range-as-a-function-of-theta","position":8},{"hierarchy":{"lvl1":"Modelling the trajectory of a badminton shuttlecock","lvl2":"Range as a function of \\theta"},"content":"\n\n%%time\nthetas = np.linspace(-180.0, 180.0, 300)\nxmax = np.zeros_like(thetas)\n\n\nfor i in range(len(thetas)):\n    theta0 = thetas[i]\n    x0, y0 = 0.0, 3.0\n    X0 = [x0, y0, v0 * np.sin(np.radians(theta0)), -v0 * np.cos(np.radians(theta0))]\n    t = np.linspace(0.0, 10.0, 10000)\n    sol = integrate.odeint(derivative, X0, t)\n    out = pd.DataFrame(sol, columns=[\"x\", \"y\", \"vx\", \"vy\"])\n    xmax[i] = out[out.y < 0.0].iloc[0].x\n\n\n\nplt.figure()\nplt.plot(thetas, xmax)\nplt.grid()\nplt.xlabel(r\"Start angle $\\theta_0$\")\nplt.ylabel(r\"Range $x_m$\")\nplt.show()\n\n\n\n\n\n","type":"content","url":"/badminton#range-as-a-function-of-theta","position":9},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity"},"type":"lvl1","url":"/gravity","position":0},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity"},"content":"","type":"content","url":"/gravity","position":1},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Scope"},"type":"lvl2","url":"/gravity#scope","position":2},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Scope"},"content":"This notebook uses the (Point Mass Dynamics) PMD class to simulate gravitational interaction between massive objects.\n\nRequired files\n\nBefore using this notebook, download the module \n\nPMD.py and put it in your working directory.","type":"content","url":"/gravity#scope","position":3},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Coding"},"type":"lvl2","url":"/gravity#coding","position":4},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Coding"},"content":"\n\n%matplotlib widget\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom scipy import integrate, optimize, spatial\nfrom matplotlib import animation, rc\nfrom PMD import PMD, distances, MetaForce\n\nrc(\"animation\", html=\"html5\")\nnp.random.seed(333)\n\n\n\nclass Gravity(PMD):\n    def __init__(self, G=6.67e-11, **kwargs):\n        \"\"\"\n        2D gravity\n        \"\"\"\n        self.G = G\n        super().__init__(**kwargs)\n\n    def derivative(self, X, t, cutoff_radius=1.0e-2):\n        \"\"\"\n        Acceleration de chaque masse !\n        \"\"\"\n        m, G = self.m, self.G\n        n = len(m)\n        P = X[: 2 * n].reshape(n, 2)\n        V = X[2 * n :].reshape(n, 2)\n        M = m * m[:, np.newaxis]\n        D, R, U = distances(P)\n        np.fill_diagonal(R, np.inf)\n        if cutoff_radius > 0.0:\n            R = np.where(R > cutoff_radius, R, cutoff_radius)\n        F = ((G * M * R**-2)[:, :, np.newaxis] * U).sum(axis=0)\n        A = (F.T / m).T\n        X2 = X.copy()\n        X2[: 2 * n] = V.flatten()\n        X2[2 * n :] = A.flatten()\n        return X2\n\n\n\n","type":"content","url":"/gravity#coding","position":5},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Animation"},"type":"lvl2","url":"/gravity#animation","position":6},{"hierarchy":{"lvl1":"Simulation of a set of bodies subjected to gravity","lvl2":"Animation"},"content":"\n\n# SETUP\nG = 1.0e03\nnr = 3\nnt = 1\nnm = nr * nt + 1\nm = np.ones(nm) * 4.0e-3\nm[0] = 1.0\nr = np.linspace(1.0, 2.0, nr)\ntheta = np.linspace(0.0, np.pi * 2, nt, endpoint=False)\nR, Theta = np.meshgrid(r, theta)\nr = np.concatenate([[0.0], R.flatten()])\ntheta = np.concatenate([[0.0], Theta.flatten()])\n\nv = np.zeros_like(r)\nv[1:] = (\n    (G * m[0] / r[1:]) ** 0.5\n    * 0.75\n    * np.random.normal(loc=1.0, scale=0.05, size=nm - 1)\n)\nx = r * np.cos(theta)\ny = r * np.sin(theta)\nvx = -v * np.sin(theta)\nvy = v * np.cos(theta)\n\nP = np.array([x, y]).transpose()\nV = np.array([vx, vy]).transpose()\n\nvG = (V * m[:, np.newaxis]).sum(axis=0) / m.sum()\nV -= vG\n\ns = Gravity(m=m, P=P, V=V, G=G, nk=4000)\ndt = 1.0e-3\nnt = 50\n\n\n\npcolors = \"r\"\ntcolors = \"k\"\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.set_aspect(\"equal\")\nmargin = 1.0\nplt.axis([-2, 2, -2, 2])\nplt.grid()\nax.axis(\"off\")\npoints = []\n\nmsize = 10.0 * (s.m / s.m.max()) ** (1.0 / 6.0)\nfor i in range(nm):\n    plc = len(pcolors)\n    pc = pcolors[i % plc]\n    tlc = len(tcolors)\n    tc = tcolors[i % tlc]\n    (trail,) = ax.plot([], [], \"-\" + tc)\n    (point,) = ax.plot([], [], \"o\" + pc, markersize=msize[i])\n    points.append(point)\n    points.append(trail)\n\n\ndef init():\n    for i in range(2 * nm):\n        points[i].set_data([], [])\n    return points\n\n\ndef animate(i):\n    s.solve(dt, nt)\n    x, y = s.xy()\n    for i in range(nm):\n        points[2 * i].set_data(x[i : i + 1], y[i : i + 1])\n        xt, yt = s.trail(i)\n        points[2 * i + 1].set_data(xt, yt)\n    return points\n\n\nanim = animation.FuncAnimation(\n    fig, animate, init_func=init, frames=1600, interval=20, blit=True\n)\n\n\nplt.close()\nanim\n# plt.show()\n\n","type":"content","url":"/gravity#animation","position":7},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D"},"type":"lvl1","url":"/molecular-dynamics","position":0},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D"},"content":"%matplotlib widget\nfrom IPython.display import Image\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib as mpl\nfrom matplotlib import animation, rc\nimport sympy as sp\nimport pandas as pd\nfrom PMD import PMD, distances\n\nsp.init_printing(use_latex=\"mathjax\")\nrc(\"animation\", html=\"html5\")\n\n\n\n","type":"content","url":"/molecular-dynamics","position":1},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D"},"type":"lvl1","url":"/molecular-dynamics#md-notebook","position":2},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D"},"content":"Atomic simulation using the Morse potential\n\nMorse potential\n\nThis notebook uses the (Point Mass Dynamics) PMD class to simulate gravitational interaction between massive objects.\n\nRequired files\n\nBefore using this notebook, download the module \n\nPMD.py and put it in your working directory.\n\nImage(\n    url=\"https://upload.wikimedia.org/wikipedia/commons/7/7a/Morse-potential.png\",\n    width=500,\n    height=500,\n)\n\n\n\n","type":"content","url":"/molecular-dynamics#md-notebook","position":3},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"PMD module"},"type":"lvl2","url":"/molecular-dynamics#pmd-module","position":4},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"PMD module"},"content":"PMD module available here: \n\nPMD.py\n\n","type":"content","url":"/molecular-dynamics#pmd-module","position":5},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Potential"},"type":"lvl2","url":"/molecular-dynamics#potential","position":6},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Potential"},"content":"\n\nDe, a, re, r = sp.symbols(\"D_e a r_e r\")\nV = De * (1 - sp.exp(-a * (r - re))) ** 2\nV\n\n\n\n","type":"content","url":"/molecular-dynamics#potential","position":7},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Force"},"type":"lvl2","url":"/molecular-dynamics#force","position":8},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Force"},"content":"\n\nF = -V.diff(r)\nF\n\n\n\n","type":"content","url":"/molecular-dynamics#force","position":9},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Plotting"},"type":"lvl2","url":"/molecular-dynamics#plotting","position":10},{"hierarchy":{"lvl1":"Molecular Dynamics : simulation of a crystal formation in 2D","lvl2":"Plotting"},"content":"\n\nvalues = {De: 1.0, a: 2.0, re: 1}\nVf = sp.lambdify(r, V.subs(values), \"numpy\")\nFf = sp.lambdify(r, F.subs(values), \"numpy\")\nvr = np.linspace(0.3 * values[re], 5 * values[re], 100)\nfig = plt.figure()\nax = fig.add_subplot(2, 1, 1)\nplt.ylim(0, 5)\nplt.plot(vr, Vf(vr))\nplt.grid()\nplt.ylabel(\"Potential Value, $V$\")\nax = fig.add_subplot(2, 1, 2)\nplt.ylim(-2.5, 5)\nplt.plot(vr, Ff(vr))\nplt.grid()\nplt.xlabel(\"Interatomic Distance, $r$\")\nplt.ylabel(\"Force Value, $F$\")\nplt.show()\n\n\n\nclass MD(PMD):\n    \"\"\"\n    Molecular dynamics w. Morse potential.\n    \"\"\"\n\n    def __init__(self, De=1.0, a=1.0, re=1.0, mu=0.0, **kwargs):\n        self.De = De\n        self.a = a\n        self.re = re\n        self.mu = mu\n        super().__init__(**kwargs)\n\n    def derivative(self, X, t, cutoff_radius=1.0e-2):\n        De, a, re, mu = self.De, self.a, self.re, self.mu\n        n = len(m)\n        P = X[: 2 * n].reshape(n, 2)\n        V = X[2 * n :].reshape(n, 2)\n        M = m * m[:, np.newaxis]\n        D, R, U = distances(P)\n        np.fill_diagonal(R, np.inf)\n        if cutoff_radius > 0.0:\n            R = np.where(R > cutoff_radius, R, cutoff_radius)\n        # F =((G * M * R**-2)[:,:,np.newaxis] * U).sum(axis = 0)\n        F = (\n            (2.0 * De * a * (1.0 - np.exp(-a * (R - re))) * np.exp(-a * (R - re)))[\n                :, :, np.newaxis\n            ]\n            * U\n        ).sum(axis=0) - mu * (V**2).sum(axis=0) ** 1.5 * V\n        A = (F.T / m).T\n        X2 = X.copy()\n        X2[: 2 * n] = V.flatten()\n        X2[2 * n :] = A.flatten()\n        return X2\n\n    def potential(self, P):\n        De, a, re, mu = self.De, self.a, self.re, self.mu\n        D, R, U = distances(P)\n        return (\n            np.where(R != 0.0, De * a * (1 - np.exp(-a * (R - re))) ** 2, 0.0).sum()\n            / 2.0\n        )\n\n\n\nnp.random.seed(666)\nre = 0.9\nnmx = 6\nnmy = 6\nnm = nmx * nmy\nx0 = np.arange(nmx) * re * 1.2\ny0 = np.arange(nmy) * re * 1.2\nX0, Y0 = np.meshgrid(x0, y0)\nP0 = np.array([X0.flatten(), Y0.flatten()]).T\nP0 *= 1.0 + np.random.rand(*P0.shape) * 0.1\nP0 -= P0.mean(axis=0)\nV0 = np.zeros_like(P0)\npcolors = \"r\"\ntcolors = \"b\"\nm = np.ones(nm) * 1.0e0\ns = MD(m=m, P=P0, V=V0, mu=0.05, re=re, a=10, De=0.5, nk=1000)\ndt = 1.0e-1\nnt = 100\n\n\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.set_aspect(\"equal\")\nax.axis(\"off\")\nmargin = 1.0\nplt.xlim(P0[:, 0].min() - margin, P0[:, 0].max() + margin)\nplt.ylim(P0[:, 1].min() - margin, P0[:, 1].max() + margin)\n# plt.grid()\n# ax.axis(\"off\")\npoints = []\n\nmsize = 10.0 * (s.m / s.m.max()) ** (1.0 / 6.0)\nfor i in range(nm):\n    plc = len(pcolors)\n    pc = pcolors[i % plc]\n    tlc = len(tcolors)\n    tc = tcolors[i % tlc]\n    (trail,) = ax.plot([], [], \"-\" + tc)\n    (point,) = ax.plot([], [], \"o\" + pc, markersize=msize[i])\n    points.append(point)\n    points.append(trail)\n\n\ndef init():\n    for i in range(2 * nm):\n        points[i].set_data([], [])\n    return points\n\n\ndef animate(i):\n    s.solve(dt, nt)  # , rtol = 1.e-8, atol = 1.e-8)\n    x, y = s.xy()\n    for i in range(nm):\n        points[2 * i].set_data(x[i : i + 1], y[i : i + 1])\n        xt, yt = s.trail(i)\n        points[2 * i + 1].set_data(xt, yt)\n    return points\n\n\nanim = animation.FuncAnimation(\n    fig, animate, init_func=init, frames=400, interval=20, blit=True\n)\n\n\n# plt.show()\nplt.close()\nanim\n\n","type":"content","url":"/molecular-dynamics#plotting","position":11},{"hierarchy":{"lvl1":"Ressources"},"type":"lvl1","url":"/ressources-1","position":0},{"hierarchy":{"lvl1":"Ressources"},"content":"The section regroups several examples using ODE integration to solve ph\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/ressources-1","position":1},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material-2","position":0},{"hierarchy":{"lvl1":"Support material"},"content":"%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom scipy.integrate import odeint\n\n\n\n","type":"content","url":"/support-material-2","position":1},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/support-material-2#support-material","position":2},{"hierarchy":{"lvl1":"Support material"},"content":"","type":"content","url":"/support-material-2#support-material","position":3},{"hierarchy":{"lvl1":"Support material","lvl2":"Background"},"type":"lvl2","url":"/support-material-2#background","position":4},{"hierarchy":{"lvl1":"Support material","lvl2":"Background"},"content":"The problem of solving differential equations is not just a mathematical concern.\nMany physical equations that describe the evolution and equilibrium of very diverse systems are differential equations.\nThere are two types of differential equations:\n\nOrdinary Differential Equations (ODE) in which the function being sought depends only on one variable, usually time t.\n\nPartial Differential Equations in which it also depends on other variables, usually space.\n\nIn this course, we are only interested in ordinary differential equations.\nPDEs are usually solved by the finite element method which requires a course on its own.\nThe notions discussed and the observations made are also largely applicable to partial differential equations.\n\nNote\n\nThis course is not a background paper on the underlying mathematical concepts.\nIt is intended to provide the scientist with the necessary notions to make choices regarding the treatment of ODEs.","type":"content","url":"/support-material-2#background","position":5},{"hierarchy":{"lvl1":"Support material","lvl2":"Problem formulation"},"type":"lvl2","url":"/support-material-2#problem-formulation","position":6},{"hierarchy":{"lvl1":"Support material","lvl2":"Problem formulation"},"content":"An ODE can be described by several characteristics.\nIn particular:\n\nIts order.\n\nIts number of equations: depending on the problem, only one here but many ODEs can be presented as systems of equations.\n\nThe explicit time dependence. If this one does not appear, the equation is said to be autonomous.\n\nLinearity: if the unknown function and its derivatives appear only multiplied by constants, then the equation is linear.\n\nOn the contrary, for example if they appear to a power other than 1 or in a sine, then the equation is non-linear.\nHere the equation is linear.\n\nExample\n\nAs an example, we can consider the case of a free and undamped oscillator.\nIts motion is described by the following equation:\\ddot x + \\omega_0^2 x = 0\n\nThe equation is linear of the second order.\nIts exact solution isx(t) = a \\cos (\\omega_0 t)\n\nwhere a \\in \\mathbb R^+ is any constant.\nThere is therefore an infinity of solutions.\n\nDepending on these characteristics, an equation will or will not have an exact known solution.\nOnly a minority of them have such a solution.\nAlthough they are not the subject of this course, the exact solutions will serve as a reference to test the approximate solutions.\n\nTo address ODEs on a systematic basis, a generic formulation is usually used that takes the form:\\dot X = f(X, t)\n\nWhere:\n\nX: t \\mapsto X(t) = [X_0(t),\\dots, X_{N-1}(t)]^T  is the unknown function.\n\nf is the ODE\n\nThis formulation is both simple and surprising, it implies that all ODEs can be written as first order equations.\nOf course, this advantage has a price: the decrease of the order goes through an increase of the number of equations through the creation of intermediate functions.\n\nExample: ODE reformulation\n\nFrom a practical point of view, formulating a problem in this way can take a bit of practice.\nLet’s take the example of the equation \n\n(1).\n\nThe unknown function x can be replaced by a vector function:X =\n\\begin{bmatrix}\nX[0] \\\\\nX[1]\n\\end{bmatrix}\n= \n\\begin{bmatrix}\nx \\\\\n\\dot x\n\\end{bmatrix}\n\nAs a consequence:\\dot X =\n\\begin{bmatrix}\n\\dot x \\\\\n\\ddot x\n\\end{bmatrix}\n\nThe equation is rewritten as\\underbrace{\\begin{bmatrix}\n\\dot x \\\\\n\\ddot x\n\\end{bmatrix}}_{\\dot X}\n = \n\\underbrace{\\begin{bmatrix}\nX[1] \\\\\n- \\omega_0^2 X[0]\n\\end{bmatrix}}_{f(X, t)}","type":"content","url":"/support-material-2#problem-formulation","position":7},{"hierarchy":{"lvl1":"Support material","lvl2":"Phase space, vector flow and integral curves"},"type":"lvl2","url":"/support-material-2#phase-space-vector-flow-and-integral-curves","position":8},{"hierarchy":{"lvl1":"Support material","lvl2":"Phase space, vector flow and integral curves"},"content":"This reformulation is not just a mathematical trick. It also informs us about the physical nature of the problem being modeled. Indeed, the vector X describes the state variables of the system. Thus, if X and t are known, the state of the system is fully determined. This has several essential consequences:\n\nThe solution of an ODE is related to the choice of initial conditions of X.\n\nOne can therefore plot the solutions of an equation in the X space called phase space.\n\nThe ODE describes the evolution of X at any point in phase space and at any time. By analogy, we can see X as a position and \\dot X = f(X, t) as the velocity of a particle in the phase space. The vector field defined by f thus behaves like the velocity field associated with a fluid flow, so it is called the vector flow.\n\nThe solution of an ODE is called the integral curve of the flow and behaves like a stream-line of it.\n\nNote\n\nFrom a mathematical point of view, the \n\nPicard-Lindelöf (a. k. a. Cauchy-Lipschitz) theorem proves the existence and uniqueness of the solution if the equation f is continuous.\n\nExample: Phase plane and Vector flow\n\nWe propose to construct the phase plane and the vector stream associated with the undamped free oscillator (see below). We note that this one is a vortex centered on the origin of the plane. We can therefore immediately guess that the solutions will be closed curves, which implies that they are oscillatory in nature.\n\nw0 = 1.0\n\n\ndef f(X, t):\n    \"\"\"\n    Undamped harmonic oscillator ODE.\n    \"\"\"\n    out = np.zeros_like(X)\n    out[0] = X[1]\n    out[1] = -(w0**2) * X[0]\n    return out\n\n\nrmax = 10.0\nnr, ntheta = 11, 10\nr = np.linspace(0.0, rmax, nr)\ntheta = np.linspace(0.0, 2.0 * np.pi, ntheta, endpoint=False)\nr, theta = np.meshgrid(r, theta)\nx = r * np.cos(theta)\ndotx = r * np.sin(theta)\n\nx = x.flatten()\ndotx = dotx.flatten()\nX = np.array([x, dotx]).T\ndotX = np.zeros_like(X)\nt = 0.0\nfor p in range(len(X)):\n    dotX[p] = f(X[p], t)\n\namin = 0.0\namax = rmax\nna = 6\na = np.linspace(amin, amax, na)\ntv = np.linspace(0.0, 2.0 * np.pi / w0, 200)\n\nfig, axes = plt.subplots(figsize=(8, 6))\naxes.set_aspect(\"equal\")\nlabel = \"Integral curve\"\nfor i in range(na):\n    \"\"\"\n    xs = a[i] * np.cos(w0 * tv)\n    dotxs = -a[i] * w0 * np.sin(w0*tv)\n    \"\"\"\n    Xs = odeint(f, [a[i], 0.0], tv)\n    xs, dotxs = Xs.T\n    plt.plot(xs, dotxs, \"r-\", label=label)\n    label = None\nplt.quiver(\n    x,\n    dotx,\n    dotX[:, 0],\n    dotX[:, 1],\n    width=0.005,\n    headwidth=4.0,\n    headlength=4.0,\n    pivot=\"mid\",\n    label=\"Vector flow\",\n)\nplt.scatter(x, dotx, marker=\"o\", c=\"b\", s=2)\n\n\nplt.grid()\nplt.title(\"Undamped Free harmonic oscillator: Phase space\")\nplt.xlabel(\"Position, $x$ [m]\")\nplt.ylabel(\"Speed, $\\dot x$ [m/s]\")\nplt.legend(loc=\"best\")\n\nplt.show()\n\n\n\n\n\n","type":"content","url":"/support-material-2#phase-space-vector-flow-and-integral-curves","position":9},{"hierarchy":{"lvl1":"Support material","lvl2":"Approximate solutions"},"type":"lvl2","url":"/support-material-2#approximate-solutions","position":10},{"hierarchy":{"lvl1":"Support material","lvl2":"Approximate solutions"},"content":"","type":"content","url":"/support-material-2#approximate-solutions","position":11},{"hierarchy":{"lvl1":"Support material","lvl3":"Background","lvl2":"Approximate solutions"},"type":"lvl3","url":"/support-material-2#background-1","position":12},{"hierarchy":{"lvl1":"Support material","lvl3":"Background","lvl2":"Approximate solutions"},"content":"The solution of an ODE in the general case is not known.\nHowever, we can calculate numerical solutions.\nThese are fundamentally different from the exact solutions.\nSuppose that we look for the solution from a starting point X_0 and on a time interval [t_a, t_b]:\n\nThe numerical solutions are approximate, i.e. they imply a certain amount of error which must be made negligible depending on the problem being addressed.\n\nThey are discrete in time, which means that the solution is described only at certain times \\left\\lbrace t_0, \\ldots, t_{N-1} \\right\\rbrace where t_0 = t_a and t_{N-1}= t_b.\nThe distance between these instants is called time step and noted dt = t_{k+1} - t_k.\nThe values of X associated to these time steps are noted \\left\\lbrace X_0, \\ldots, X_{N-1} \\right\\rbrace","type":"content","url":"/support-material-2#background-1","position":13},{"hierarchy":{"lvl1":"Support material","lvl3":"Problem formulation","lvl2":"Approximate solutions"},"type":"lvl3","url":"/support-material-2#problem-formulation-1","position":14},{"hierarchy":{"lvl1":"Support material","lvl3":"Problem formulation","lvl2":"Approximate solutions"},"content":"To solve this problem, we can use integration schemes to determine X_{k+1} from X_k.\nFrom a starting point X_0, they allow to determine all the X_k values step by step on the desired duration.\nFrom a mathematical point of view, the problem is therefore to determine:X_{k+1} = X_k + \\int_{t=t_k}^{t_{k+1}} f(X(t), t) dt\n\nThis integral is of course not known and must be approximated efficiently.","type":"content","url":"/support-material-2#problem-formulation-1","position":15},{"hierarchy":{"lvl1":"Support material","lvl3":"Naive solution: Forward Euler","lvl2":"Approximate solutions"},"type":"lvl3","url":"/support-material-2#naive-solution-forward-euler","position":16},{"hierarchy":{"lvl1":"Support material","lvl3":"Naive solution: Forward Euler","lvl2":"Approximate solutions"},"content":"The simplest approach to solve this problem is to evaluate \\dot X_k, the slope of in (X_k, t_k) and follow this direction to t_k.\nThis leads to the following integration scheme:X_{k+1} = X_k + f(X_k, t_k)  dt\n\nThis approach means that:\\int_{t=t_k}^{t_{k+1}} f(X(t), t) dt \\approx f(X_k,t_k)  dt\n\nThis is equivalent to approximating the integral by the method of left rectangles (or left Riemann sum). This method of integration is called the explicit Euler method or the forward Euler method. It is attributed to \n\nLeonhard Euler.  This method has the merit of being easy to write:\n\ndef Euler(func, X0, t):\n    \"\"\"\n    Euler solver.\n    \"\"\"\n    dt = t[1] - t[0]\n    nt = len(t)\n    X = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt - 1):\n        X[i + 1] = X[i] + func(X[i], t[i]) * dt\n    return X\n\n\n\n# SETTINGS\nw0 = 2.0 * np.pi\nT0 = 2.0 * np.pi / w0\nnt = 10  # NUMBER OF TIME STEPS\ndt = T0 / 4 / nt  # TIME STEP\nx0 = 1.0\nX0 = np.array([x0, 0.0])\n\n# NUMERICAL SOLUTION\nt = np.arange(nt + 1) * dt\nX = Euler(f, X0, t)\n\n# EXACT SOLUTION\nts = np.linspace(t.min(), t.max(), 1000)\nXs = np.array([x0 * np.cos(w0 * ts), -x0 * w0 * np.sin(w0 * ts)]).T\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\n# ax.set_aspect(\"equal\")\nplt.plot(ts, Xs[:, 0], \"-k\", label=\"Exact Solution: $X$\")\nplt.plot(t, X[:, 0], \"or--\", label=\"Approx. Sol: $X_k$\")\nplt.quiver(\n    t,\n    X[:, 0],\n    np.ones_like(t) * dt,\n    X[:, 1] * dt,\n    color=\"b\",\n    angles=\"xy\",\n    scale_units=\"xy\",\n    zorder=2,\n    width=0.005,\n    headwidth=4.0,\n    headlength=4.0,\n    label=\"Slope: $\\dot X_k = f(X_k, t_k)$\",\n)\nplt.legend()\nplt.xticks(t, [f\"$t_{{{k}}}$\" for k in range(len(t))])\nplt.grid()\nplt.xlabel(\"Time, $t$ [s]\")\nplt.ylabel(\"Position, $x$ [m]\")\nplt.show()\n\n\n\n\n\nThe above example shows that the error between the exact solution and the approximate solution is clearly visible and is probably not negligible. We can reduce the time step dt to limit this error.\n\n# SETTINGS\nw0 = 2.0 * np.pi\nT0 = 2.0 * np.pi / w0\nx0 = 1.0\nX0 = np.array([x0, 0.0])\n\nfig, ax = plt.subplots(figsize=(8, 6))\n# ax.set_aspect(\"equal\")\nplt.plot(ts, Xs[:, 0], \"-k\", label=\"Exact Solution: $X$\")\nfor nt in [2, 5, 10, 20]:\n    dt = T0 / 4 / nt  # TIME STEP\n    t = np.arange(nt + 1) * dt\n    X = Euler(f, X0, t)\n    plt.plot(t, X[:, 0], \"+-\", label=f\"dt={dt:.2e} s\")\n\nplt.legend()\nplt.xticks(t, [f\"$t_{{{k}}}$\" for k in range(len(t))])\nplt.grid()\nplt.xlabel(\"Time, $t$ [s]\")\nplt.ylabel(\"Position, $x$ [m]\")\nplt.show()\n\n\n\nReducing dt does give a better approximation. We say that the algorithm converges to the solution when dt tends to 0. This rate of convergence can be shown by measuring the error:e(dt) = \\sqrt{\\dfrac{1}{k}\\sum_k (x_k - x_s(t_k))^2}\n\nWhere x_s is the exact solution and e the error.\nLet’s plot this error as a function of dt:\n\n# SETTINGS\nw0 = 2.0 * np.pi\nT0 = 2.0 * np.pi / w0\nx0 = 1.0\nX0 = np.array([x0, 0.0])\nnt_values = np.array([10, 50, 100, 500, 1000])\nerr = np.zeros(len(nt_values))\ndt_values = T0 / 4 / nt_values\nfor i in range(len(dt_values)):\n    dt = dt_values[i]\n    t = np.arange(nt + 1) * dt\n    X = Euler(f, X0, t)\n    res = ((x0 * np.cos(w0 * t) - X[:, 0]) ** 2)[1:]\n    res /= len(res)\n    err[i] = np.sqrt(res.sum())\n\nfig, ax = plt.subplots(figsize=(8, 6))\nplt.plot(dt_values, err, \"o-\", label=\"Forward Euler\")\nplt.legend()\nplt.yscale(\"log\")\nplt.xscale(\"log\")\nplt.grid()\nplt.ylabel(\"Error on position, $e(dt)$ [m]\")\nplt.xlabel(\"Time step, $dt$ [s]\")\nplt.title(\"Forward Euler convergence to solution\")\nplt.show()\n\n\n\nWe see that Euler’s method converges to the exact solution when dt decreases. We can therefore chose the time step to limit the error to a value of our choice.","type":"content","url":"/support-material-2#naive-solution-forward-euler","position":17},{"hierarchy":{"lvl1":"Support material","lvl3":"Runge-Kutta 4 method","lvl2":"Approximate solutions"},"type":"lvl3","url":"/support-material-2#runge-kutta-4-method","position":18},{"hierarchy":{"lvl1":"Support material","lvl3":"Runge-Kutta 4 method","lvl2":"Approximate solutions"},"content":"There are many improvements of the Euler forward method. The \n\nRunge and Kutta methods are an example widely used in the literature, in particular the Runge-Kutta 4 (forward) algorithm which is written as follows:\\begin{align}\nk_1 & = f(X_k, t_k) \\\\\nk_2 & = f(X_k + \\dfrac{k_1}{2}dt, t_k + \\dfrac{dt}{2}) \\\\\nk_3 & = f(X_k + \\dfrac{k_2}{2}dt, t_k + \\dfrac{dt}{2}) \\\\\nk_4 & = f(X_k + k_3dt, t_k + dt) \\\\\nX_{k+1} & = X_{k} + \\dfrac{1}{6}\\left( k_1 + 2 k_2 + 2k_3 + k_4 \\right)\n\\end{align}\n\ndef RK4(func, X0, t):\n    \"\"\"\n    Runge Kutta 4 solver.\n    \"\"\"\n    dt = t[1] - t[0]\n    nt = len(t)\n    X = np.zeros([nt, len(X0)])\n    X[0] = X0\n    for i in range(nt - 1):\n        k1 = func(X[i], t[i])\n        k2 = func(X[i] + dt / 2.0 * k1, t[i] + dt / 2.0)\n        k3 = func(X[i] + dt / 2.0 * k2, t[i] + dt / 2.0)\n        k4 = func(X[i] + dt * k3, t[i] + dt)\n        X[i + 1] = X[i] + dt / 6.0 * (k1 + 2.0 * k2 + 2.0 * k3 + k4)\n    return X\n\n\n\n","type":"content","url":"/support-material-2#runge-kutta-4-method","position":19},{"hierarchy":{"lvl1":"Support material","lvl3":"Built-in methods","lvl2":"Approximate solutions"},"type":"lvl3","url":"/support-material-2#built-in-methods","position":20},{"hierarchy":{"lvl1":"Support material","lvl3":"Built-in methods","lvl2":"Approximate solutions"},"content":"Also built-in integration methods are available. The \n\nodeint function of Scipy is an example. We propose to compare it with the two others.\n\nfrom scipy.integrate import odeint\n\n\n\n# SETTINGS\nw0 = 2.0 * np.pi\nT0 = 2.0 * np.pi / w0\nx0 = 1.0\nX0 = np.array([x0, 0.0])\nnt_values = np.array([10, 50, 100, 500, 1000])\n\nmethods = {\"Euler\": Euler, \"RK4\": RK4, \"odeint\": odeint}\nerr = {meth: np.zeros(len(nt_values)) for meth, _ in methods.items()}\ndt_values = T0 / 4 / nt_values\nfor i in range(len(dt_values)):\n    dt = dt_values[i]\n    t = np.arange(nt + 1) * dt\n    for key, integrator in methods.items():\n        X = integrator(f, X0, t)\n        res = ((x0 * np.cos(w0 * t) - X[:, 0]) ** 2)[1:]\n        res /= len(res)\n        err[key][i] = np.sqrt(res.sum())\n\nfig, ax = plt.subplots(figsize=(8, 6))\nfor key, e in err.items():\n    plt.plot(dt_values, e, \"o-\", label=key)\nplt.legend()\nplt.yscale(\"log\")\nplt.xscale(\"log\")\nplt.grid()\nplt.ylabel(\"Error on position, $e(dt)$ [m]\")\nplt.xlabel(\"Time step, $dt$ [s]\")\nplt.title(\"Convergence of multiple algorithms\")\nplt.show()\n\n\n\nThe graph above shows that the error levels and convergence rates of the 3 methods above are very different. We can first compare the forward Euler and RK4 methods. The latter evaluates the ODE 4 times per iteration and can therefore be considered as four times slower that the Forward Euler method. However, its error level is several orders of magnitude lower and its convergence rate is much better than forward Euler. Concerning odeint, we notice that this last algorithm has a much lower error level than Euler but a comparable convergence rate. In fact it uses an error control system which we will not detail here. However, we must remember that odeint is fast and reliable in many cases.","type":"content","url":"/support-material-2#built-in-methods","position":21},{"hierarchy":{"lvl1":"Support material"},"type":"lvl1","url":"/optimization-basics","position":0},{"hierarchy":{"lvl1":"Support material"},"content":"Author: Emile Roux (\n\nemile​.roux@univ​-smb​.fr), Ludovic Charleux\n\n..This notebook is ready for  \n\nRISE Slideshow\n\n# Setup\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib\n\nparams = {\n    \"font.size\": 14,\n    \"figure.figsize\": (10.0, 6.0),\n    \"lines.linewidth\": 2.0,\n    \"lines.markersize\": 8,\n}\nmatplotlib.rcParams.update(params)\n\n\n\n","type":"content","url":"/optimization-basics","position":1},{"hierarchy":{"lvl1":"Support material","lvl2":"General Scope"},"type":"lvl2","url":"/optimization-basics#general-scope","position":2},{"hierarchy":{"lvl1":"Support material","lvl2":"General Scope"},"content":"Optimization is the process of finding the best solution to a problem under a set of constraints. It is a fundamental concept in many fields, including mathematics, engineering, economics, and computer science. Optimization plays a critical role in various applications, including product design, scheduling, logistics, finance, and data analysis.\n\nThe goal of optimization is to find the optimal value of a function, which is a measure of the objective of the problem. The objective function can be either to maximize or minimize a certain quantity, depending on the nature of the problem. The optimal solution is the set of values of the decision variables that maximizes or minimizes the objective function while satisfying the constraints.\n\n","type":"content","url":"/optimization-basics#general-scope","position":3},{"hierarchy":{"lvl1":"Support material","lvl3":"Optimization probleme formulation","lvl2":"General Scope"},"type":"lvl3","url":"/optimization-basics#optimization-probleme-formulation","position":4},{"hierarchy":{"lvl1":"Support material","lvl3":"Optimization probleme formulation","lvl2":"General Scope"},"content":"The formulation of an optimization problem (minimization or maximization) goes through the following steps:\n\nObjective: The goal to be achieved by optimization.\n\nVariables: The elements that can be adjusted to achieve the objective.\n\nConstraints: The limits or rules that must be respected during optimization.\n\nObjective function: The mathematical function that must be optimized to achieve the objective.\n\nResolution method: The technique used to find the best possible solution taking into account the objective, variables, constraints, and the objective function.\n\nExample\n\nThe Traveling Salesman Optimization Problem:\n\nObjective: Minimize the total distance traveled by a salesman visiting a set of cities and returning to the starting point.\n\nVariables: Binary variables representing whether a path between two cities is taken or not.\n\nConstraints: Each city must be visited exactly once (except the starting and ending city).\n\nObjective function: A function that calculates the total distance traveled based on the binary variables representing the chosen paths.\n\nResolution method: Combinatoir optimization methode\n\nExample\n\nThe mechanical design optimization problem of a structural part:\n\nObjective: Maximize the strength of the structural part while minimizing its weight.\n\nVariables:Section, dimensions of the part.\n\nConstraints:\n\nStress constraints to ensure that the part can withstand the applied loads without failure.\n\nManufacturing constraints such as minimum feature sizes and wall thicknesses.\n\nObjective function: A function that calculates the strength of the part based on the chosen design variables and the applied loads, while taking into account the weight of the part.\n\nResolution method: Gradient base optimisation methode that include constraint if necessary.\n\n","type":"content","url":"/optimization-basics#optimization-probleme-formulation","position":5},{"hierarchy":{"lvl1":"Support material","lvl3":"Exemple of the design process","lvl2":"General Scope"},"type":"lvl3","url":"/optimization-basics#exemple-of-the-design-process","position":6},{"hierarchy":{"lvl1":"Support material","lvl3":"Exemple of the design process","lvl2":"General Scope"},"content":"The conventional approach, described below, consists of a series of trial and error steps until a design that meets the specifications is obtained.\n\nThis approach, if it involves prototyping, can be very time consuming and resource intensive.\n\n\n\nAutomatique optimization can help to improve a design process.\n\nThe trial and error phase is replaced by an automatic phase: performance evaluation (cost function) combine with design modification.\n\n\n\nThis automation allows to save time in the development process.\n\nBut it has a counterpart, it is necessary upstream to formulate the optimization problem and to be able to evaluate automatically a possible disgne.\n\n{citep:ps}‘mdobook2022’\n\n","type":"content","url":"/optimization-basics#exemple-of-the-design-process","position":7},{"hierarchy":{"lvl1":"Support material","lvl2":"Mathematical formulation"},"type":"lvl2","url":"/optimization-basics#mathematical-formulation","position":8},{"hierarchy":{"lvl1":"Support material","lvl2":"Mathematical formulation"},"content":"\n\n","type":"content","url":"/optimization-basics#mathematical-formulation","position":9},{"hierarchy":{"lvl1":"Support material","lvl3":"Scope","lvl2":"Mathematical formulation"},"type":"lvl3","url":"/optimization-basics#scope","position":10},{"hierarchy":{"lvl1":"Support material","lvl3":"Scope","lvl2":"Mathematical formulation"},"content":"Mathematical optimization aims at solving various kinds of problems by minimizing a function of the form:f(X) = e\n\nWhere f if the cost function, X is a N dimensional vector of parameters and e \\in \\mathscr R.\n\nMore informations about the underlying theory, the nature of the solution(s) and practical considerations can be found:\n\nOn \n\nWikipedia,\n\nOn (excellent) \n\nScipy lectures.","type":"content","url":"/optimization-basics#scope","position":11},{"hierarchy":{"lvl1":"Support material","lvl3":"Solving","lvl2":"Mathematical formulation"},"type":"lvl3","url":"/optimization-basics#solving","position":12},{"hierarchy":{"lvl1":"Support material","lvl3":"Solving","lvl2":"Mathematical formulation"},"content":"Scipy offers multiple approaches in order to solve optimization problems in its sub package optimize","type":"content","url":"/optimization-basics#solving","position":13},{"hierarchy":{"lvl1":"Support material","lvl3":"General purpose approach","lvl2":"Mathematical formulation"},"type":"lvl3","url":"/optimization-basics#general-purpose-approach","position":14},{"hierarchy":{"lvl1":"Support material","lvl3":"General purpose approach","lvl2":"Mathematical formulation"},"content":"scipy​.optimize​.minimize allows one to use multiple general purpose optimization algorithms.\n\nBelow a basic exemple is presented :\n\nObjective: Finde the mimimun au a finction f.\n\nVariables: X.\n\nConstraints: Nonz.\n\nObjective function: f(X) = \\sum_{i}^{} X_i.\n\nResolution method: Neder-mead methode (local minmum finding, an initial guess is mandatory).\n\nfrom scipy import optimize\n\n\ndef f(X):\n    \"\"\"\n    Cost function.\n    \"\"\"\n    return ((X - 1) ** 2).sum()\n\n\nX0 = [0.0, 0.0]  # Initial guess\nsol = optimize.minimize(f, X0, method=\"nelder-mead\")\nX = sol.x\nprint(\"Solution: \", X)\n\n\n\n","type":"content","url":"/optimization-basics#general-purpose-approach","position":15},{"hierarchy":{"lvl1":"Support material","lvl2":"Specif case of curve fitting using least squares"},"type":"lvl2","url":"/optimization-basics#specif-case-of-curve-fitting-using-least-squares","position":16},{"hierarchy":{"lvl1":"Support material","lvl2":"Specif case of curve fitting using least squares"},"content":"In order to perform curve fitting in a more convenient way, \n\nscipy​.optimize​.curve​_fit can be used.\n\ndef func(x, omega, tau):\n    return np.exp(-x / tau) * np.sin(omega * x)\n\n\nxdata = np.linspace(0, 3.0, 100)\ny = func(xdata, omega=2.0 * np.pi, tau=10.0)\nydata = y + 0.5 * np.random.normal(size=len(xdata))\n\nparams, cov = optimize.curve_fit(func, xdata, ydata)\nomega, tau = params\nysol = func(xdata, omega, tau)\n\n\nfig = plt.figure(0)\nplt.clf()\nplt.plot(xdata, y, label=\"Target\")\nplt.plot(xdata, ydata, \"o\", label=\"Target + noise\")\nplt.plot(xdata, ysol, label=\"Solution\")\nplt.grid()\nplt.xlabel(\"$x$\")\nplt.ylabel(\"$y$\")\nplt.legend()\nplt.show()\n\n\n\n","type":"content","url":"/optimization-basics#specif-case-of-curve-fitting-using-least-squares","position":17},{"hierarchy":{"lvl1":"Optimizing a bridge structure"},"type":"lvl1","url":"/bridge-optimization","position":0},{"hierarchy":{"lvl1":"Optimizing a bridge structure"},"content":"","type":"content","url":"/bridge-optimization","position":1},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Installation of the truss package"},"type":"lvl2","url":"/bridge-optimization#installation-of-the-truss-package","position":2},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Installation of the truss package"},"content":"For this session, you will need the Python \n\ntruss package. The following cell will install it automatically.\n\n# FOR JUPYTER LAB\n%matplotlib notebook\n# FOR JUPYTER NOTEBOOK AND HUB\n# % matplotlib notebook\nimport numpy as np\nimport matplotlib.pyplot as plt\nimport sys\nimport os\nimport zipfile\nimport urllib.request\nimport shutil\nfrom scipy import optimize\n\n\nurl = \"https://github.com/lcharleux/truss/archive/master.zip\"\nfile_name = \"truss-master.zip\"\n\nwith urllib.request.urlopen(url) as response, open(file_name, \"wb\") as out_file:\n    shutil.copyfileobj(response, out_file)\n    with zipfile.ZipFile(file_name) as zf:\n        zf.extractall()\n\nos.remove(file_name)\n\nsys.path.append(\"truss-master\")\ntry:\n    import truss\n\n    print(\"Truss is correctly installed\")\nexcept:\n    print(\"Truss is NOT correctly installed !\")\n\n\n\nA short truss tutorial is available here:\n\nhttp://​truss​.readthedocs​.io​/en​/latest​/tutorial​.html\n\n","type":"content","url":"/bridge-optimization#installation-of-the-truss-package","position":3},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Building the bridge structure"},"type":"lvl2","url":"/bridge-optimization#building-the-bridge-structure","position":4},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Building the bridge structure"},"content":"In this session, we will modelled a bridge structure using truss and optimize it using various criteria. The basic structure is introduced below. It is made of steel bars and loaded with one vertical force on G. The bridge is symmetrical so only the left half is modelled.\n\nE = 210.0e9  # Young Modulus [Pa]\nrho = 7800.0  # Density       [kg/m**3]\nA = 5.0e-2  # Cross section [m**2]\nsigmay = 400.0e6  # Yield Stress  [Pa]\n\n# Model definition\nmodel = truss.core.Model()  # Model definition\n\n# NODES\nnA = model.add_node((0.0, 0.0), label=\"A\")\nnC = model.add_node((3.0, 0.0), label=\"C\")\nnD = model.add_node((3.0, 3.0), label=\"D\")\nnE = model.add_node((6.0, 0.0), label=\"E\")\nnF = model.add_node((6.0, 3.0), label=\"F\")\nnG = model.add_node((9.0, 0.0), label=\"G\")\nnH = model.add_node((9.0, 3.0), label=\"H\")\n\n# BOUNDARY CONDITIONS\nnA.block[1] = True\nnG.block[0] = True\nnH.block[0] = True\n\n# BARS\nAC = model.add_bar(nA, nC, modulus=E, density=rho, section=A, yield_stress=sigmay)\nCD = model.add_bar(nC, nD, modulus=E, density=rho, section=A, yield_stress=sigmay)\nAD = model.add_bar(nA, nD, modulus=E, density=rho, section=A, yield_stress=sigmay)\nCE = model.add_bar(nC, nE, modulus=E, density=rho, section=A, yield_stress=sigmay)\nDF = model.add_bar(nD, nF, modulus=E, density=rho, section=A, yield_stress=sigmay)\nDE = model.add_bar(nD, nE, modulus=E, density=rho, section=A, yield_stress=sigmay)\nEF = model.add_bar(nE, nF, modulus=E, density=rho, section=A, yield_stress=sigmay)\nEG = model.add_bar(nE, nG, modulus=E, density=rho, section=A, yield_stress=sigmay)\nFH = model.add_bar(nF, nH, modulus=E, density=rho, section=A, yield_stress=sigmay)\nFG = model.add_bar(nF, nG, modulus=E, density=rho, section=A, yield_stress=sigmay)\nGH = model.add_bar(nG, nH, modulus=E, density=rho, section=A, yield_stress=sigmay)\n\n# STRUCTURAL LOADING\nnG.force = np.array([0.0, -1.0e6])\n\n\nmodel.solve()\n\n\nxlim, ylim = model.bbox(deformed=False)\nfig = plt.figure()\nax = fig.add_subplot(1, 1, 1)\nax.set_aspect(\"equal\")\n# ax.axis(\"off\")\nmodel.draw(\n    ax, deformed=False, field=\"stress\", label=True, force_scale=1.0e-6, forces=True\n)\nplt.xlim(xlim)\nplt.ylim(ylim)\nplt.grid()\nplt.xlabel(\"Axe $x$\")\nplt.ylabel(\"Axe $y$\")\n\n\n\n\n\n","type":"content","url":"/bridge-optimization#building-the-bridge-structure","position":5},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl3":"Read Data","lvl2":"Building the bridge structure"},"type":"lvl3","url":"/bridge-optimization#read-data","position":6},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl3":"Read Data","lvl2":"Building the bridge structure"},"content":"","type":"content","url":"/bridge-optimization#read-data","position":7},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Detailed results at the nodes","lvl3":"Read Data","lvl2":"Building the bridge structure"},"type":"lvl4","url":"/bridge-optimization#detailed-results-at-the-nodes","position":8},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Detailed results at the nodes","lvl3":"Read Data","lvl2":"Building the bridge structure"},"content":"\n\nmodel.data(at=\"nodes\")\n\n\n\n","type":"content","url":"/bridge-optimization#detailed-results-at-the-nodes","position":9},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Detailed results on the bars","lvl3":"Read Data","lvl2":"Building the bridge structure"},"type":"lvl4","url":"/bridge-optimization#detailed-results-on-the-bars","position":10},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Detailed results on the bars","lvl3":"Read Data","lvl2":"Building the bridge structure"},"content":"\n\nmodel.data(at=\"bars\")\n\n\n\n","type":"content","url":"/bridge-optimization#detailed-results-on-the-bars","position":11},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Dead (or structural) mass","lvl3":"Read Data","lvl2":"Building the bridge structure"},"type":"lvl4","url":"/bridge-optimization#dead-or-structural-mass","position":12},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Dead (or structural) mass","lvl3":"Read Data","lvl2":"Building the bridge structure"},"content":"\n\nm0 = model.mass()\nm0 * 1.0e-3  # Mass in tons !\n\n\n\n","type":"content","url":"/bridge-optimization#dead-or-structural-mass","position":13},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl3":"Model modification","lvl2":"Building the bridge structure"},"type":"lvl3","url":"/bridge-optimization#model-modification","position":14},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl3":"Model modification","lvl2":"Building the bridge structure"},"content":"","type":"content","url":"/bridge-optimization#model-modification","position":15},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Modifing section","lvl3":"Model modification","lvl2":"Building the bridge structure"},"type":"lvl4","url":"/bridge-optimization#modifing-section","position":16},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Modifing section","lvl3":"Model modification","lvl2":"Building the bridge structure"},"content":"\n\n# change section of one bar\nFG.section = 0.0333\n\n# solve with updated sections\nmodel.solve()\n\nmodel.data(at=\"bars\")\n\n\n\n","type":"content","url":"/bridge-optimization#modifing-section","position":17},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Changing all section (or other parameters)","lvl3":"Model modification","lvl2":"Building the bridge structure"},"type":"lvl4","url":"/bridge-optimization#changing-all-section-or-other-parameters","position":18},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl4":"Changing all section (or other parameters)","lvl3":"Model modification","lvl2":"Building the bridge structure"},"content":"\n\n# loop over bars\nfor bar in model.bars:\n    # get the normal force of the bar\n    N = bar.tension\n\n    # change the section\n    bar.section = 0.2\n\n\n# solve with updated parameters\nmodel.solve()\n\n\n\n","type":"content","url":"/bridge-optimization#changing-all-section-or-other-parameters","position":19},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Questions"},"type":"lvl2","url":"/bridge-optimization#questions","position":20},{"hierarchy":{"lvl1":"Optimizing a bridge structure","lvl2":"Questions"},"content":"\n\nQuestion 1: Verify that the yield stress is not exceeded anywhere, do you think this structure has an optimimum weight ? You can use the state/failure data available on the whole model.\n\n# Example:\nmodel.data(at=\"bars\").state.failure.values\n\n# ...\n\n\n\nQuestion 2: Modify all the cross sections at the same time in order to minimize weight while keeping acceptable stress level.\n\n\n\n\n\nQuestion 3: We want to modify the position along the \\vec y axis of the points D, F and H in order to minimize the vertical displacement of the node G times the mass of the structure \\alpha:\\alpha = |u_y(G)| m\n\nWhere u_y(G) is the displacement of the node G along the \\vec y axis and m the mass of the whole structure.\n\nDo not further modify the sections determined in question 4. Comment the solution.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nQuestion 4: Same question with displacements also along \\vec x of C, D, E and F. Is it better ?\n\n\n\n\n\n\n\n\n\nQuestion 5:  You can now try to perform topological optimization by removing/merging well chosen beams and nodes. In order to make the structure even more efficient.\n\n\n\n\n\nQuestion 6: You are now asked to optimize the cross section along with the position of C, D, E and F in order to reach the yield stress in each individual beam.","type":"content","url":"/bridge-optimization#questions","position":21},{"hierarchy":{"lvl1":"Exercices"},"type":"lvl1","url":"/exercises-4","position":0},{"hierarchy":{"lvl1":"Exercices"},"content":"In this section, we propose quick exercises that can typically be done in an hour and a half.\n\nRosenbrock function and Curve fiting (duration: 1.5 h): introductory exercise that proposes to implement :\n\nan optimization method to find the minimum of an analytical function (the rosenbrock function).\n\na curve fitting method\n\nPractical work\n\nIn this section, we propose longer exercises that can be done without assistance, typically in 4 hours.\n\nOptimizing a bridge structure (duration: 4 h): In this session, we will modelled a bridge structure using truss and optimize it using various criteria.","type":"content","url":"/exercises-4","position":1},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting"},"type":"lvl1","url":"/rosenbrock-and-curve-fiting","position":0},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting"},"content":"","type":"content","url":"/rosenbrock-and-curve-fiting","position":1},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl2":"The Rosenbrock function"},"type":"lvl2","url":"/rosenbrock-and-curve-fiting#the-rosenbrock-function","position":2},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl2":"The Rosenbrock function"},"content":"The \n\nRosenbrock function is a classical benchmark for optimization algorithms. It is defined by the following equation:f(x, y) = (1-x)^2 + 100 (y-x^2)^2\n\n%matplotlib inline\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef Rosen(X):\n    \"\"\"\n    Rosenbrock function\n    \"\"\"\n    x, y = X\n    return (1 - x) ** 2 + 100.0 * (y - x**2) ** 2\n\n\nx = np.linspace(-2.0, 2.0, 100)\ny = np.linspace(-1.0, 3.0, 100)\nX, Y = np.meshgrid(x, y)\nZ = Rosen((X, Y))\n\nfig = plt.figure(0)\nplt.clf()\nplt.contourf(X, Y, Z, 20)\nplt.colorbar()\nplt.contour(X, Y, Z, 20, colors=\"black\")\nplt.grid()\nplt.xlabel(\"x\")\nplt.ylabel(\"y\")\nplt.show()\n\n\n\n","type":"content","url":"/rosenbrock-and-curve-fiting#the-rosenbrock-function","position":3},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl3":"Questions","lvl2":"The Rosenbrock function"},"type":"lvl3","url":"/rosenbrock-and-curve-fiting#questions","position":4},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl3":"Questions","lvl2":"The Rosenbrock function"},"content":"Find the minimum of the function using brute force. Comment the accuracy and number of function evaluations.\n\nSame question with the simplex (Nelder-Mead) algorithm.","type":"content","url":"/rosenbrock-and-curve-fiting#questions","position":5},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl2":"Curve fitting"},"type":"lvl2","url":"/rosenbrock-and-curve-fiting#curve-fitting","position":6},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl2":"Curve fitting"},"content":"","type":"content","url":"/rosenbrock-and-curve-fiting#curve-fitting","position":7},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl3":"Questions","lvl2":"Curve fitting"},"type":"lvl3","url":"/rosenbrock-and-curve-fiting#questions-1","position":8},{"hierarchy":{"lvl1":"Rosenbrock function and Curve fiting","lvl3":"Questions","lvl2":"Curve fitting"},"content":"Chose a mathematical function y = f(x, a, b) and code it.\n\nChose target values of a and b that you will try to find back using optimization.\n\nEvaluate it on a grid of x values.\n\nAdd some noise to the result.\n\nFind back a and b using curve_fit","type":"content","url":"/rosenbrock-and-curve-fiting#questions-1","position":9},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method"},"type":"lvl1","url":"/stepbystep-optimization","position":0},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method"},"content":"%matplotlib widget\n# %matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import optimize\nimport ipywidgets as ipw\nfrom matplotlib import cm\nimport ipywidgets as widgets\n\n\n\n","type":"content","url":"/stepbystep-optimization","position":1},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl2":"Cost functions"},"type":"lvl2","url":"/stepbystep-optimization#cost-functions","position":2},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl2":"Cost functions"},"content":"\n\n","type":"content","url":"/stepbystep-optimization#cost-functions","position":3},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Goldstein–Price function","lvl2":"Cost functions"},"type":"lvl3","url":"/stepbystep-optimization#goldstein-price-function","position":4},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Goldstein–Price function","lvl2":"Cost functions"},"content":"\n\ndef cost(p):\n    global counterCostCall\n    \"\"\"\n    Goldstein–Price.\n    https://en.wikipedia.org/wiki/Test_functions_for_optimization    \"\"\"\n\n    x, y = p\n    f = (\n        1\n        + (\n            (x + y + 1) ** 2\n            * (19 - 14 * x + 3 * x**2 - 14 * y + 6 * x * y + 3 * y**2)\n        )\n    ) * (\n        30\n        + (2 * x - 3 * y) ** 2\n        * (18 - 32 * x + 12 * x**2 + 48 * y - 36 * x * y + 27 * y**2)\n    )\n    return f / 80000.0\n\n\ncounterCostCall = 0\nNx, Ny = 100, 100\nx = np.linspace(-1.5, 1.5, Nx)\ny = np.linspace(-1.5, 1.5, Ny)\nX, Y = np.meshgrid(x, y)\nzf = np.array([X.flatten(), Y.flatten()])\nZ = cost(zf).reshape(Nx, Ny)\nZ = np.where(Z > 0.3, np.nan, Z)\nmask = np.ones_like(Z)\n\n\n\n","type":"content","url":"/stepbystep-optimization#goldstein-price-function","position":5},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Himmelblau cost function","lvl2":"Cost functions"},"type":"lvl3","url":"/stepbystep-optimization#himmelblau-cost-function","position":6},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Himmelblau cost function","lvl2":"Cost functions"},"content":"\n\ndef cost(p):\n    global counterCostCall\n    \"\"\"\n    Himmelblau cost function.\n    https://en.wikipedia.org/wiki/Himmelblau%27s_function\n    \"\"\"\n\n    x, y = p\n    return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n\ncounterCostCall = 0\nNx, Ny = 100, 100\nx = np.linspace(-5.0, 5.0, Nx)\ny = np.linspace(-5.0, 5.0, Ny)\nX, Y = np.meshgrid(x, y)\nzf = np.array([X.flatten(), Y.flatten()])\nZ = cost(zf).reshape(Nx, Ny)\nZ = np.where(Z > 200.0, np.nan, Z)\n\nmask = np.ones_like(Z)\n\n\n\nP = np.zeros((1000, 2)) * np.nan\nV_down_hill_dir = np.zeros((1000, 2)) * np.nan\n\n\nP[0] = 3.0, -0.0\n\n\ndef maj_mask_all(mask, Pis):\n    for Pi in Pis:\n        if ~np.isnan(Pi[0]):\n            mask = maj_mask(mask, Pi)\n    return mask\n\n\ndef maj_mask(mask, Pi):\n    R = 0.5\n    mask[np.sqrt((X - Pi[0]) ** 2 + (Y - Pi[1]) ** 2) < R] = np.nan\n    return mask\n\n\nmask = maj_mask(mask, P[0])\n\n\ndef init(px=0.0, py=-4.0):\n    global mask, P, V_down_hill_dir\n    mask = np.ones_like(Z)\n    P = np.zeros((1000, 2)) * np.nan\n    V_down_hill_dir = np.zeros((1000, 2)) * np.nan\n    P[0] = px, py\n\n\n\n","type":"content","url":"/stepbystep-optimization#himmelblau-cost-function","position":7},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl2":"Gradiant based methode"},"type":"lvl2","url":"/stepbystep-optimization#gradiant-based-methode","position":8},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl2":"Gradiant based methode"},"content":"\n\n","type":"content","url":"/stepbystep-optimization#gradiant-based-methode","position":9},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Down hill methode","lvl2":"Gradiant based methode"},"type":"lvl3","url":"/stepbystep-optimization#down-hill-methode","position":10},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Down hill methode","lvl2":"Gradiant based methode"},"content":"\n\ndef grad_P(Pi):\n    # Gradient computation using finite difference approach\n    eps = 0.001\n    Pdx = Pi.copy()\n    Pdx[0] = Pdx[0] + eps\n    gradx = (cost(Pdx) - cost(Pi)) / eps\n\n    Pdy = Pi.copy()\n    Pdy[1] = Pdy[1] + eps\n    grady = (cost(Pdy) - cost(Pi)) / eps\n    return np.array([gradx, grady])\n\n\ndef optim_grad():\n    global counter, P, V_down_hill_dir\n    # compute gradient at curent point\n    g = grad_P(P[counter])\n    g_normalized = g / np.linalg.norm(g)\n    # compute down hill direction\n    down_hill_dir = -g_normalized\n    V_down_hill_dir[counter] = down_hill_dir\n    step = 0.1\n    # compute next point with a constante step in down hill dir\n    P[counter + 1] = P[counter] + step * down_hill_dir\n    counter += 1\n\n\n\n","type":"content","url":"/stepbystep-optimization#down-hill-methode","position":11},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Down hill methode with linear search","lvl2":"Gradiant based methode"},"type":"lvl3","url":"/stepbystep-optimization#down-hill-methode-with-linear-search","position":12},{"hierarchy":{"lvl1":"Step by step Optimization : understanding gradient based method","lvl3":"Down hill methode with linear search","lvl2":"Gradiant based methode"},"content":"\n\ndef optim_grad_lin_search():\n    global counter, P, V_down_hill_dir\n    # compute gradient at curent point\n    g = grad_P(P[counter])\n    g_normalized = g / np.linalg.norm(g)\n    # compute down hill direction\n    down_hill_dir = -g_normalized\n    V_down_hill_dir[counter] = down_hill_dir\n    step = 0.1\n    go = True\n    while go:\n        P_new = P[counter] + step * down_hill_dir\n        if cost(P_new) > cost(P[counter]):\n            go = False\n        else:\n            P[counter + 1] = P_new\n            counter += 1\n\n\n\ninit(px=-0.32, py=-0.62)\nalpha = 0.7\nmask = maj_mask_all(mask, P)\n\nplt.figure(figsize=(6, 4))\ntitle = plt.title(\"\")\ncost_map = plt.contourf(X, Y, np.log(Z), 100, cmap=cm.jet)\nplt.colorbar(cost_map)\nplt.contour(X, Y, np.log(Z), 500, cmap=cm.gray, zorder=2.0, linewidths=0.2)\nplt.contour(X, Y, np.log(Z), 50, cmap=cm.gray, zorder=2.0, linewidths=0.5)\n(line,) = plt.plot(P[:, 0], P[:, 1], \".g\", label=\"Path\")\n(line0,) = plt.plot(P[:1, 0], P[:1, 1], \"r\", label=\"Start\")\n\n\nv = plt.quiver(\n    P[:, 0],\n    P[:, 1],\n    V_down_hill_dir[:, 0],\n    V_down_hill_dir[:, 1],\n    scale=10,\n    zorder=2.4,\n    width=0.005,\n    label=\"DownHill Dir\",\n    angles=\"xy\",\n)\np = [plt.contourf(X, Y, mask, 2, cmap=cm.gray, zorder=2.3, alpha=alpha)]\n\nplt.legend()\nplt.tight_layout()\n# get ax object\nax = plt.gca()\n\ncounter = 0\n\n\n@ipw.interact_manual()\ndef run_step():\n    global P, counter, mask, v, V_down_hill_dir\n\n    # optim_grad()\n    optim_grad_lin_search()\n\n    mask = maj_mask_all(mask, P)\n\n    for tp in p[0].collections:\n        tp.remove()\n    v.remove()\n\n    p[0] = plt.contourf(X, Y, mask, 2, cmap=cm.gray, zorder=2.3, alpha=alpha)\n    v = plt.quiver(\n        P[:, 0],\n        P[:, 1],\n        V_down_hill_dir[:, 0],\n        V_down_hill_dir[:, 1],\n        scale=10,\n        zorder=2.4,\n        width=0.005,\n        label=\"DownHill Dir\",\n        angles=\"xy\",\n    )\n    line.set_xdata(P[:, 0])\n    line.set_ydata(P[:, 1])\n    re = 1.0\n    # get last point which is not nan\n    last_P = P[np.where(~np.isnan(P[:, 0]))][-1]\n    # ax.set_xlim([last_P[0] - re, last_P[0] + re])\n    # ax.set_ylim([last_P[1] - re, last_P[1] + re])\n\n    # CostOverIt.set_ydata(cost(P.T))\n\n\n\n\n\n\n\n","type":"content","url":"/stepbystep-optimization#down-hill-methode-with-linear-search","position":13},{"hierarchy":{"lvl1":"Interactive optimization"},"type":"lvl1","url":"/interactive-optimization","position":0},{"hierarchy":{"lvl1":"Interactive optimization"},"content":"","type":"content","url":"/interactive-optimization","position":1},{"hierarchy":{"lvl1":"Table of Contents"},"type":"lvl1","url":"/interactive-optimization#table-of-contents","position":2},{"hierarchy":{"lvl1":"Table of Contents"},"content":"\n\n","type":"content","url":"/interactive-optimization#table-of-contents","position":3},{"hierarchy":{"lvl1":"Interactive optimization"},"type":"lvl1","url":"/interactive-optimization#interactive-optimization","position":4},{"hierarchy":{"lvl1":"Interactive optimization"},"content":".. codeauthor:: Emile Roux, Ludovic Charleux","type":"content","url":"/interactive-optimization#interactive-optimization","position":5},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Background"},"type":"lvl2","url":"/interactive-optimization#background","position":6},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Background"},"content":"The starting point, also known as the initial guess or initial solution, is crucial in optimization because it can greatly impact the outcome of the optimization process.\nIn optimization, the goal is to find the optimal solution that maximizes or minimizes a certain objective function.\nIf the initial guess is far from the optimal solution, it may take a long time for the algorithm to converge to the optimal solution, or it may converge to a suboptimal solution instead.\nTherefore, selecting a good starting point that is close to the optimal solution can greatly improve the efficiency and accuracy of the optimization process.\n\nAs alternative to over come this issue, global optimization algorithms can be used. The use of the \n\nDIRECT algorithm presented here to illustarte the concept of global optimization.\n\nThe Goal of this notebook is to understand this keypoint of optimisation.\n\n%matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import optimize\n\nimport ipywidgets as ipw\nfrom matplotlib import cm\n\n\n\n","type":"content","url":"/interactive-optimization#background","position":7},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Definition of the cost function"},"type":"lvl2","url":"/interactive-optimization#definition-of-the-cost-function","position":8},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Definition of the cost function"},"content":"The 2D Himmelblau cost function is used to illustrate the starting point importantce.\n\n\nhttps://en.wikipedia.org/wiki/Himmelblau's_function\n\ndef cost(p):\n    global counter, P\n    \"\"\"\n    Himmelblau cost function.\n    https://en.wikipedia.org/wiki/Himmelblau%27s_function\n    \"\"\"\n    x, y = p\n    return (x**2 + y - 11) ** 2 + (x + y**2 - 7) ** 2\n\n\nNx, Ny = 100, 100\nx = np.linspace(-5.0, 5.0, Nx)\ny = np.linspace(-5.0, 5.0, Ny)\nX, Y = np.meshgrid(x, y)\nzf = np.array([X.flatten(), Y.flatten()])\nZ = cost(zf).reshape(Nx, Ny)\nZ = np.where(Z > 200.0, np.nan, Z)\n\nplt.figure()\ntitle = plt.title(\"\")\nplt.contourf(X, Y, Z, 20, cmap=cm.jet)\nplt.colorbar()\nplt.contour(X, Y, Z, 20, cmap=cm.gray)\nplt.show()\n\n\n\nThis 2D function shows 4 different minima.\n\n","type":"content","url":"/interactive-optimization#definition-of-the-cost-function","position":9},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Bluid a animated plot to have fun with starting points"},"type":"lvl2","url":"/interactive-optimization#bluid-a-animated-plot-to-have-fun-with-starting-points","position":10},{"hierarchy":{"lvl1":"Interactive optimization","lvl2":"Bluid a animated plot to have fun with starting points"},"content":"\n\ncounter = 1\nP = np.zeros((1000, 2))\nP[0] = -1.0, 0.0\n\n\ndef cost_and_track(xk):\n    global counter, P\n    P[counter, :] = xk\n    counter += 1\n    return cost(xk)\n\n\nplt.figure()\ntitle = plt.title(\"\")\nplt.contourf(X, Y, Z, 20, cmap=cm.jet, alpha=0.5)\nplt.colorbar()\nplt.contour(X, Y, Z, 20, cmap=cm.gray)\n(line,) = plt.plot(P[:, 0], P[:, 1], \"om\", label=\"Path\")\n(line0,) = plt.plot(P[:1, 0], P[:1, 1], \"r*\", label=\"Start\")\n(line1,) = plt.plot(\n    P[counter - 1 : counter, 0], P[counter - 1 : counter, 1], \"bs\", label=\"End\"\n)\nplt.grid()\nplt.legend()\n# plt.tight_layout()\n\n\n@ipw.interact(\n    x0=(-4.0, 4, 0.1),\n    y0=(-4.0, 4, 0.1),\n    algorithm=[\"Nelder-Mead\", \"BFGS\", \"Powell\", \"DIRECT\"],\n)\ndef run_optimization(x0=0.0, y0=0.0, algorithm=\"Nelder-Mead\"):\n    global P, counter, counterCostCall\n    counter = 1\n    P *= np.nan\n    P[0] = x0, y0\n    if algorithm == \"DIRECT\":\n        bounds = optimize.Bounds([-6.0, -6.0], [6.0, 6.0])\n        sol = optimize.direct(\n            cost_and_track, bounds, f_min=-1.0, eps=1e-2, vol_tol=1e-10\n        )\n    else:\n        sol = optimize.minimize(cost_and_track, [x0, y0], method=algorithm)\n    line.set_xdata(P[:, 0])\n    line.set_ydata(P[:, 1])\n    line0.set_xdata(P[:1, 0])\n    line0.set_ydata(P[:1, 1])\n    line1.set_xdata(P[counter - 1 : counter, 0])\n    line1.set_ydata(P[counter - 1 : counter, 1])\n    title.set_text(\n        \"Alg:{0}, CostCall: {1}, sol=({2:.1f},{3:.1f})\".format(\n            algorithm, counter, sol.x[0], sol.x[1]\n        )\n    )\n\n\n\n\n\nBy changing the starting point and optimization method, we can observe:\n\nThe optimization process converged toward different minimum.\n\nNumber of iterations is not constant.","type":"content","url":"/interactive-optimization#bluid-a-animated-plot-to-have-fun-with-starting-points","position":11},{"hierarchy":{"lvl1":"Ressources"},"type":"lvl1","url":"/ressources-2","position":0},{"hierarchy":{"lvl1":"Ressources"},"content":"The section regroups several examples to have a better understanding of optimization key points.\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/ressources-2","position":1},{"hierarchy":{"lvl1":"Illustration : Crossing a river"},"type":"lvl1","url":"/river-crossing-and-more","position":0},{"hierarchy":{"lvl1":"Illustration : Crossing a river"},"content":"# %matplotlib notebook\n%matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import optimize\nimport ipywidgets as ipw\nfrom matplotlib import cm\nimport ipywidgets as widgets\nfrom scipy import integrate\n\n\n\n","type":"content","url":"/river-crossing-and-more","position":1},{"hierarchy":{"lvl1":"Illustration : Crossing a river"},"type":"lvl1","url":"/river-crossing-and-more#illustration-crossing-a-river","position":2},{"hierarchy":{"lvl1":"Illustration : Crossing a river"},"content":"This example deal with the case of a person who wants to cross a river in a minimum of time.\n\nProblem statement:\n\nthe velocity on the ground is 10 km/h\n\nthe swimming velocity is 1 km/h\n\nthe starting point and the ending point are fixed\n\nthe width of the river is fixed (40m)\n\nBased on this problem we will go through the formulation of the optimization method and its resolution.\nThe following points have to be addressed :\n\nProblem formulation\n\nObjective\n\nVariables\n\nConstraints\n\nObjective function\n\nResolution method\n\n","type":"content","url":"/river-crossing-and-more#illustration-crossing-a-river","position":3},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Problem statement : model formulation"},"type":"lvl2","url":"/river-crossing-and-more#problem-statement-model-formulation","position":4},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Problem statement : model formulation"},"content":"","type":"content","url":"/river-crossing-and-more#problem-statement-model-formulation","position":5},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Where is the river :  model the river","lvl2":"Problem statement : model formulation"},"type":"lvl3","url":"/river-crossing-and-more#where-is-the-river-model-the-river","position":6},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Where is the river :  model the river","lvl2":"Problem statement : model formulation"},"content":"The river is an area wher the velocity is lower.\n\ngroung_v = 10.0 / 3.6\nswim_v = 1.0 / 3.6\n\ny1_river = 40\ny2_river = 80\n\n\ndef world_definition(x, y):\n    v = swim_v * np.ones_like(x)\n    v[y <= y1_river] = groung_v\n    v[y > y2_river] = groung_v\n    return v\n\n\nx = np.linspace(0, 100, 100)\ny = np.linspace(0, 120, 150)\nx_world, y_world = np.meshgrid(x, y, indexing=\"xy\")\nv_world = world_definition(x_world, y_world)\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\nplt.title(\"Velocity map [m/s]\")\nplt.colorbar()\nplt.show()\n\n\n\n","type":"content","url":"/river-crossing-and-more#where-is-the-river-model-the-river","position":7},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Defintion of the path","lvl2":"Problem statement : model formulation"},"type":"lvl3","url":"/river-crossing-and-more#defintion-of-the-path","position":8},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Defintion of the path","lvl2":"Problem statement : model formulation"},"content":"\n\npath = np.array([[5.0, 5.0], [15.0, y1_river], [25, y2_river], [80, 85]])\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\nplt.plot(path[:, 0], path[:, 1], \"go-\")\nplt.title(\"Velocity map [m/s]\")\nplt.colorbar()\n\n\n\n","type":"content","url":"/river-crossing-and-more#defintion-of-the-path","position":9},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl2","url":"/river-crossing-and-more#model-the-river-crossing-compute-the-velocity-and-the-duration-to-go-trougth-the-path","position":10},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"first lrt’s work on one segment of the path :\n\ndef arc_duration(seg, nb_sub=20):\n    seg = seg.T\n    sub = np.linspace(seg[:, 0], seg[:, 1], nb_sub)\n    sub = sub[:-1] + np.diff(sub, axis=0) / 2\n    sub_length = np.linalg.norm(np.diff(seg)) / (nb_sub - 1)\n    v = world_definition(sub[:, 0], sub[:, 1])\n    duration = (sub_length / v).sum()\n    return duration, sub, v\n\n\n\n# test for one segment of the path\nseg = path[:2, :]\nduration, sub, v = arc_duration(seg, nb_sub=20)\nduration\n\n\n\nNow we can work on the full path :\n\ntotal = 0\nfor i in range(len(path) - 1):\n    seg = path[i : i + 2, :]\n    duration, sub, v = arc_duration(seg, nb_sub=20)\n    total += duration\n    print(\"segment {0} : {1:0.2f}s\".format(i, duration))\nprint(\"Total   : {0:0.2f}s\".format(total))\n\n\n\ndef total_duration(path, blabla=False):\n    total = 0.0\n    for i in range(len(path) - 1):\n        seg = path[i : i + 2, :].copy()\n        duration, _, _ = arc_duration(seg, nb_sub=20)\n        total += duration\n        if blabla:\n            print(\"segment {0} : {1:0.1f}s\".format(i, duration))\n    if blabla:\n        print(\"Total   : {0:0.1f}s\".format(total))\n    return total\n\n\n# test for the path\ntotal_duration(path, blabla=True)\n\n\n\n\n\n","type":"content","url":"/river-crossing-and-more#model-the-river-crossing-compute-the-velocity-and-the-duration-to-go-trougth-the-path","position":11},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Widget plot","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl3","url":"/river-crossing-and-more#widget-plot","position":12},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Widget plot","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"\n\nplt.figure()\n(l,) = plt.plot(path[:, 0], path[:, 1], \"y-o\")\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\ntitle = plt.title(\"duration\")\n\n\n@ipw.interact(x1=(0.0, 100, 1), x2=(0.0, 100, 1))\ndef update(x1=30, x2=30):\n    path[1, 0] = x1\n    path[2, 0] = x2\n    t_total = total_duration(path, blabla=False)\n    l.set_data(path[:, 0], path[:, 1])\n    title.set_text(\"Total   : {0:0.1f}s\".format(t_total))\n\n\n\n\n\n","type":"content","url":"/river-crossing-and-more#widget-plot","position":13},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl3","url":"/river-crossing-and-more#what-is-the-optimal-solution","position":14},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"","type":"content","url":"/river-crossing-and-more#what-is-the-optimal-solution","position":15},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl4":"First idea : test all combination","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl4","url":"/river-crossing-and-more#first-idea-test-all-combination","position":16},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl4":"First idea : test all combination","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"\n\nNx, Ny = 30, 30\nx1 = np.linspace(5, 100, Nx)\nx2 = np.linspace(5, 100, Ny)\nX, Y = np.meshgrid(x1, x2)\nZ = np.zeros_like(X)\n\nfor i in range(len(X)):\n    for j in range(len(Y)):\n        path[1, 0] = X[i, j]\n        path[2, 0] = Y[i, j]\n        Z[i, j] = total_duration(path, blabla=False)\n\n\n\n","type":"content","url":"/river-crossing-and-more#first-idea-test-all-combination","position":17},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl5":"Find the min","lvl4":"First idea : test all combination","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl5","url":"/river-crossing-and-more#find-the-min","position":18},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl5":"Find the min","lvl4":"First idea : test all combination","lvl3":"What is the optimal solution ?","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"\n\nx1_min, x2_min = np.where(np.min(Z) == Z)\nX_min = X[x1_min, x2_min]\nY_min = Y[x1_min, x2_min]\nprint(X_min, Y_min)\n\n\n\nplt.figure()\ntitle = plt.title(\"\")\n# plt.contourf(X, Y, Z, 20, cmap=cm.jet)\n# plt.colorbar()\n# plt.contour(X, Y, Z, 20, cmap=cm.gray)\nplt.scatter(X, Y, c=Z, s=50, cmap=cm.jet)\nplt.plot(X_min, Y_min, \"*y\")\nplt.colorbar()\nplt.xlabel(\"Diving position [m]\")\nplt.ylabel(\"Dout of water [m]\")\nplt.show()\n\n\n\n","type":"content","url":"/river-crossing-and-more#find-the-min","position":19},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Is that realistic with a finer grid ? (or in larger dimension)","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl3","url":"/river-crossing-and-more#is-that-realistic-with-a-finer-grid-or-in-larger-dimension","position":20},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Is that realistic with a finer grid ? (or in larger dimension)","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"\n\n%%timeit\ntotal_duration(path, blabla=False)\n\n\n\n","type":"content","url":"/river-crossing-and-more#is-that-realistic-with-a-finer-grid-or-in-larger-dimension","position":21},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Usning optimization methode","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"type":"lvl3","url":"/river-crossing-and-more#usning-optimization-methode","position":22},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Usning optimization methode","lvl2":"Model the river crossing : compute the velocity and the duration to go trougth the path"},"content":"\n\ndef cost(X):\n    path[1, 0] = X[0]\n    path[2, 0] = X[1]\n    return total_duration(path, blabla=False)\n\n\n\nfrom scipy import optimize\n\n\n\nsol = optimize.minimize(cost, [10.0, 10.0], method=\"Nelder-Mead\")\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\nplt.plot(path[:, 0], path[:, 1], \"go-\", label=\"optimal path\")\nplt.title(\"Velocity map [m/s]\")\nplt.legend()\nplt.colorbar()\n\n\n\n","type":"content","url":"/river-crossing-and-more#usning-optimization-methode","position":23},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Crossing another river : higer dimension"},"type":"lvl2","url":"/river-crossing-and-more#crossing-another-river-higer-dimension","position":24},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Crossing another river : higer dimension"},"content":"The person can swim faster close to the river side.\n\ndef world_definition(x, y):\n    v = swim_v * np.ones_like(x)\n    v = swim_v + (1 - 0.8 * np.cos(2 * np.pi * (y - 60) / 40))\n    v[y <= y1_river] = groung_v\n    v[y > y2_river] = groung_v\n    return v\n\n\nx = np.linspace(0, 100, 100)\ny = np.linspace(0, 120, 150)\n\nx_world, y_world = np.meshgrid(x, y, indexing=\"xy\")\nv_world = world_definition(x_world, y_world)\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\nplt.title(\"Velocity map\")\nplt.colorbar()\nplt.show()\n\n\n\nIs that still relevant to go straight ?\n\n","type":"content","url":"/river-crossing-and-more#crossing-another-river-higer-dimension","position":25},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Add more control points","lvl2":"Crossing another river : higer dimension"},"type":"lvl3","url":"/river-crossing-and-more#add-more-control-points","position":26},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"Add more control points","lvl2":"Crossing another river : higer dimension"},"content":"\n\npath_init = np.linspace([5.0, 5.0], [80.0, 100.0], 10)\npath = np.copy(path_init)\n\n\n\ndef cost_n_points(X):\n    for i in range(len(X)):\n        path[i + 1, 0] = X[i]\n    return total_duration(path, blabla=False)\n\n\n\ninit_guess = np.copy(path_init[:-2, 0])\nsol = optimize.minimize(cost_n_points, init_guess, method=\"Nelder-Mead\")\nX = sol.x\nfor i in range(len(X)):\n    path[i + 1, 0] = X[i]\n\n\n\nsol\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0, alpha=0.5)\nplt.plot(path_init[:, 0], path_init[:, 1], \"o:g\")\nplt.plot(path[:, 0], path[:, 1], \"o-r\")\nplt.title(\"Velocity map\")\nplt.colorbar()\n\n\n\n","type":"content","url":"/river-crossing-and-more#add-more-control-points","position":27},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Add constrainte : Crossing a river with a crocodile"},"type":"lvl2","url":"/river-crossing-and-more#add-constrainte-crossing-a-river-with-a-crocodile","position":28},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl2":"Add constrainte : Crossing a river with a crocodile"},"content":"\n\n# Low velocity\ndef invexp(x, y, tau, cx, cy):\n    return np.exp(-(((x - cx) / tau) ** 2) - ((y - cy) / tau) ** 2)\n\n\ndef world_definition(x, y):\n    v = swim_v * np.ones_like(x)\n    v = swim_v + (1 - 0.8 * np.cos(2 * np.pi * (y - 60) / 40))\n    tau = 5\n    v = v * ((1 + 0.1) - invexp(x, y, tau, 50, 60))\n    v[y <= y1_river] = groung_v\n    v[y > y2_river] = groung_v\n    return v\n\n\nx = np.linspace(0, 100, 100)\ny = np.linspace(0, 120, 150)\n\nx_world, y_world = np.meshgrid(x, y, indexing=\"xy\")\nv_world = world_definition(x_world, y_world)\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0)\nplt.title(\"Velocity map\")\nplt.colorbar()\nplt.show()\n\n\n\n","type":"content","url":"/river-crossing-and-more#add-constrainte-crossing-a-river-with-a-crocodile","position":29},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"With 2 parametres  (2D Problems)","lvl2":"Add constrainte : Crossing a river with a crocodile"},"type":"lvl3","url":"/river-crossing-and-more#with-2-parametres-2d-problems","position":30},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"With 2 parametres  (2D Problems)","lvl2":"Add constrainte : Crossing a river with a crocodile"},"content":"\n\npath = np.array([[5.0, 5.0], [15.0, y1_river], [25, y2_river], [80, 85]])\n\n\n\nNx, Ny = 25, 25\nx1 = np.linspace(5, 100, Nx)\nx2 = np.linspace(5, 100, Ny)\nX, Y = np.meshgrid(x1, x2)\nZ = np.zeros_like(X)\nfor i in range(len(X)):\n    for j in range(len(Y)):\n        path[1, 0] = X[i, j]\n        path[2, 0] = Y[i, j]\n        Z[i, j] = total_duration(path, blabla=False)\n\n\n\nx1_min, x2_min = np.where(np.min(Z) == Z)\nX_min = X[x1_min, x2_min]\nY_min = Y[x1_min, x2_min]\nprint(X_min, Y_min)\n\n\n\nplt.figure()\ntitle = plt.title(\"\")\nplt.contourf(X, Y, Z, 20, cmap=cm.jet)\nplt.colorbar()\nplt.contour(X, Y, Z, 20, cmap=cm.gray)\nplt.scatter(X, Y, c=Z, s=20, cmap=cm.jet)\nplt.plot(X_min, Y_min, \"or\")\nplt.xlabel(\"Diving position [m]\")\nplt.ylabel(\"Dout of water [m]\")\nplt.show()\n\n\n\n","type":"content","url":"/river-crossing-and-more#with-2-parametres-2d-problems","position":31},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"With N parametres  (ND Problems)","lvl2":"Add constrainte : Crossing a river with a crocodile"},"type":"lvl3","url":"/river-crossing-and-more#with-n-parametres-nd-problems","position":32},{"hierarchy":{"lvl1":"Illustration : Crossing a river","lvl3":"With N parametres  (ND Problems)","lvl2":"Add constrainte : Crossing a river with a crocodile"},"content":"\n\nN = 20\npath_init = np.linspace([5.0, 5.0], [80.0, 100.0], N)\npath = np.copy(path_init)\n\n\ndef cost_n_points(X):\n    for i in range(len(X)):\n        path[i + 1, 0] = X[i]\n    return total_duration(path, blabla=False)\n\n\n\ninit_guess\n\n\n\ninit_guess = 5 + np.random.rand(path_init[:-2, 0].shape[0]) * 80.0\npath_init[1:-1, 0] = init_guess\nsol = optimize.minimize(cost_n_points, init_guess, method=\"Nelder-Mead\")\nX = sol.x\nfor i in range(len(X)):\n    path[i + 1, 0] = X[i]\n\n\n\nplt.figure()\nplt.contourf(x_world, y_world, v_world, 20, cmap=cm.terrain, vmax=10.0, alpha=0.5)\nplt.plot(path_init[:, 0], path_init[:, 1], \"o:g\")\nplt.plot(path[:, 0], path[:, 1], \"o-r\")\nplt.title(\"Velocity map\")\nplt.colorbar()\n\n","type":"content","url":"/river-crossing-and-more#with-n-parametres-nd-problems","position":33},{"hierarchy":{"lvl1":"Examples"},"type":"lvl1","url":"/examples","position":0},{"hierarchy":{"lvl1":"Examples"},"content":"This section provides examples of problems handled with Python.\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/examples","position":1},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons"},"type":"lvl1","url":"/game-of-life-full","position":0},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons"},"content":"# UNCOMMENT FOR INTERACTIVE PLOTTING\n# %matplotlib notebook\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation, rc, cm\nimport IPython, io, urllib\nimport requests\nimport warnings\n\nwarnings.filterwarnings(\"ignore\")\n\nrc(\"animation\", html=\"html5\")\n\n\n\n","type":"content","url":"/game-of-life-full","position":1},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Introduction"},"type":"lvl2","url":"/game-of-life-full#introduction","position":2},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Introduction"},"content":"This notebook was inspired by the great video proposed by David Louapre available on his Youtube channel “Science Etonnante”:\n\nIPython.display.YouTubeVideo(\"S-W0NX97DB0\")\n\n\n\nThe Game of Life (GoL) is a good way to learn about the use of object oriented programming, numpy and matplotlib. It is also a very interresting scientific and mathematical problem. The GoL belongs to the wider group of problems called Cellular Automatons. A lot of alternative sets of interresting rules have been created/discovered over time since the invention of the GoL. In this tutorial, we introduce a simple class that can solve all those problems called Life Like Cellular Automatons (LLCA).\n\nFurther readings:\n\nLife-like cellular automaton\n\n","type":"content","url":"/game-of-life-full#introduction","position":3},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"A generic class to simulate LLCAs"},"type":"lvl2","url":"/game-of-life-full#a-generic-class-to-simulate-llcas","position":4},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"A generic class to simulate LLCAs"},"content":"\n\nclass LLCA:\n    \"\"\"\n    A Life Like Cellular Automaton (LLCA)\n\n    Inputs:\n    * C: a binary matrix representing the cells where 1 stands for alive and 0 for dead.\n    * rule: the rule of the in the format 'BXSY' where X and Y are the birth and survival conditions.\n            Example: GOL rule is \"B3S23\".\n    \"\"\"\n\n    def __init__(self, C=np.random.rand(50, 50), rule=\"B3S23\"):\n        self.C = np.array(C).astype(bool)\n        self.rule = rule\n\n    def parse_rule(self):\n        \"\"\"\n        Parses the rule string\n        \"\"\"\n        r = self.rule.upper().split(\"S\")\n        B = np.array([int(i) for i in r[0][1:]]).astype(np.int64)\n        S = np.array([int(i) for i in r[1]]).astype(np.int64)\n        return B, S\n\n    def neighbors(self):\n        \"\"\"\n        Returns the number of living neigbors of each cell.\n        \"\"\"\n        C = self.C\n        N = np.zeros(C.shape, dtype=np.int8)  # Neighbors matrix\n        N[:-1, :] += C[1:, :]  # Living cells south\n        N[:, :-1] += C[:, 1:]  # Living cells east\n        N[1:, :] += C[:-1, :]  # Living cells north\n        N[:, 1:] += C[:, :-1]  # Living cells west\n        N[:-1, :-1] += C[1:, 1:]  # Living cells south east\n        N[1:, :-1] += C[:-1, 1:]  # Living cells north east\n        N[1:, 1:] += C[:-1, :-1]  # Living cells north west\n        N[:-1, 1:] += C[1:, :-1]  # Living cells south west\n        return N\n\n    def iterate(self):\n        \"\"\"\n        Iterates one time.\n        \"\"\"\n        B, S = self.parse_rule()\n        N = self.neighbors()\n        C = self.C\n        C1 = np.zeros(C.shape, dtype=np.int8)\n        for b in B:\n            C1 += (C == False) & (N == b)\n        for s in S:\n            C1 += C & (N == s)\n        self.C[:] = C1 > 0\n\n\n\n","type":"content","url":"/game-of-life-full#a-generic-class-to-simulate-llcas","position":5},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"The orginal Game of Life  (rule B3S23)"},"type":"lvl2","url":"/game-of-life-full#the-orginal-game-of-life-rule-b3s23","position":6},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"The orginal Game of Life  (rule B3S23)"},"content":"\n\n# INITIAL CONFIGURATION\nN = 100\nt = np.linspace(0.0, 1.0, N + 1)\nX, Y = np.meshgrid(t, t)\nf = 4\nC0 = np.sin(2.0 * np.pi * f * X) * np.sin(2.0 * np.pi * 2 * f * Y) > -0.1\ng = LLCA(C0, rule=\"B3S23\")\n\n\n# ANIMATION\ndef updatefig(*args):\n    g.iterate()\n    im.set_array(g.C)\n    return (im,)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.axis(\"off\")\nim = plt.imshow(g.C, interpolation=\"nearest\", cmap=cm.binary, animated=True)\nanim = animation.FuncAnimation(fig, updatefig, frames=200, interval=50, blit=True)\n\nplt.close()\nanim\n# plt.show()\n\n\n\n","type":"content","url":"/game-of-life-full#the-orginal-game-of-life-rule-b3s23","position":7},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Alternative rule:  Day and Night (B3678S34678)"},"type":"lvl2","url":"/game-of-life-full#alternative-rule-day-and-night-b3678s34678","position":8},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Alternative rule:  Day and Night (B3678S34678)"},"content":"\n\nN = 100\nt = np.linspace(0.0, 1.0, N + 1)\nX, Y = np.meshgrid(t, t)\nf = 10\nC0 = np.sin(2.0 * np.pi * f * X) * np.sin(2.0 * np.pi * 2 * f * Y) > 0.0\n\ng = LLCA(C0, rule=\"B3678S34678\")\n\n\ndef updatefig(*args):\n    g.iterate()\n    im.set_array(g.C)\n    return (im,)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.axis(\"off\")\nim = plt.imshow(g.C, interpolation=\"nearest\", cmap=cm.binary, animated=True)\nanim = animation.FuncAnimation(fig, updatefig, frames=200, interval=50, blit=True)\nplt.close()\nanim\n# plt.show()\n\n\n\n","type":"content","url":"/game-of-life-full#alternative-rule-day-and-night-b3678s34678","position":9},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Alternative rule: fractal-like B1S123"},"type":"lvl2","url":"/game-of-life-full#alternative-rule-fractal-like-b1s123","position":10},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Alternative rule: fractal-like B1S123"},"content":"\n\nN = 200\nC0 = np.zeros((N, N))\nC0[1, 1] = 1\n\ng = LLCA(C0, rule=\"B1S123\")\n\n\ndef updatefig(*args):\n    g.iterate()\n    im.set_array(g.C)\n    return (im,)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nax.axis(\"off\")\nim = plt.imshow(g.C, interpolation=\"nearest\", cmap=cm.binary, animated=True)\nanim = animation.FuncAnimation(fig, updatefig, frames=200, interval=40, blit=True)\nplt.close()\nanim\n# plt.show()\n\n\n\n","type":"content","url":"/game-of-life-full#alternative-rule-fractal-like-b1s123","position":11},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Existing structures in GoL"},"type":"lvl2","url":"/game-of-life-full#existing-structures-in-gol","position":12},{"hierarchy":{"lvl1":"Game of Life and other cellular automatons","lvl2":"Existing structures in GoL"},"content":"Over time, many structures have been discovered in GoL.\nFor example, some of them are translating leaving debris in their wake.\nThey are called puffers.\nHere is an example:\n\nhttps://​conwaylife​.com​/wiki​/Hivenudger_2\n\ndef get_gol_structure_by_url(url):\n    \"\"\"\n    Gets a GoL structure using plain text format on an url.\n    \"\"\"\n    content = requests.get(url, stream=True).content.decode()\n    out = []\n    for line in content.split(\"\\n\"):\n        line = line.strip()\n        # print(line)\n        if not line.startswith(\"!\"):\n            line_data = []\n            for c in line:\n                if c == \".\":\n                    line_data.append(0)\n                if c == \"O\":\n                    line_data.append(1)\n            out.append(line_data)\n    max_length = 0\n    for line in out:\n        if len(line) > max_length:\n            max_length = len(line)\n    for line in out:\n        if len(line) < max_length:\n            for i in range(max_length - len(line)):\n                line.append(0)\n    out = np.array(out)\n    return out\n\n\nurl = \"https://conwaylife.com/patterns/hivenudger2.cells\"\ninner_cells = get_gol_structure_by_url(url)\ninner_shape = inner_cells.shape\nhmargin = 5\nlmargin = 50\nrmargin = 5\ncells = np.zeros((inner_shape[0] + hmargin * 2, inner_shape[1] + lmargin + rmargin))\ncells[hmargin:-hmargin, lmargin:-rmargin] = inner_cells\n\n\n\ng = LLCA(\n    cells, rule=\"B3S23\"\n)  # B2S23 means Birth if 2 living neighbours and survival if 2 or 3 living neighbours\n\n\ndef updatefig(*args):\n    g.iterate()\n    im.set_array(g.C)\n    return (im,)\n\n\nfig, ax = plt.subplots(figsize=(8, 6))\nim = plt.imshow(g.C, interpolation=\"nearest\", cmap=cm.binary, animated=True)\nanim = animation.FuncAnimation(fig, updatefig, frames=200, interval=50, blit=True)\nax.axis(\"off\")\nplt.tight_layout()\nplt.close()\nanim\n\n","type":"content","url":"/game-of-life-full#existing-structures-in-gol","position":13},{"hierarchy":{"lvl1":"Exercises"},"type":"lvl1","url":"/exercises","position":0},{"hierarchy":{"lvl1":"Exercises"},"content":"POSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/exercises","position":1},{"hierarchy":{"lvl1":"Conway’s Game of Life"},"type":"lvl1","url":"/game-of-life-tutorial","position":0},{"hierarchy":{"lvl1":"Conway’s Game of Life"},"content":"","type":"content","url":"/game-of-life-tutorial","position":1},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 1: Introduction"},"type":"lvl2","url":"/game-of-life-tutorial#part-1-introduction","position":2},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 1: Introduction"},"content":"","type":"content","url":"/game-of-life-tutorial#part-1-introduction","position":3},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"What’s the game of life?","lvl2":"Part 1: Introduction"},"type":"lvl3","url":"/game-of-life-tutorial#whats-the-game-of-life","position":4},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"What’s the game of life?","lvl2":"Part 1: Introduction"},"content":"The game of life (GoL)is not a game per se.\nIt is one of the first cellular automata.\nIt can be visualized as a chessboard of arbitrary size in which each cell can exist in two states (dead=0 or alive=1).\nThe game has an evolution rule that makes the state of its cell change with each time step.\nThis rule is purely deterministic (which implies that there is no randomness in this game) and is based on the number of living \n\nMoore neighbors of each square.\n\nThis rule can be written as follows:\n\nBirth (B): if a dead cell has 3 neighbors, it becomes alive 1. It remains dead 0 otherwise.\n\nSurvival (S): If a living cell has 2 or 3 neighbors of Moore, it survives thus remains 1, it dies and becomes 0 otherwise.\n\nThe rule of the game of life can be generalized as B3/S23. You can visualize the game graphically on the following simulator: \n\nhttps://​bitstorm​.org​/gameoflife/","type":"content","url":"/game-of-life-tutorial#whats-the-game-of-life","position":5},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"Further readings","lvl2":"Part 1: Introduction"},"type":"lvl3","url":"/game-of-life-tutorial#further-readings","position":6},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"Further readings","lvl2":"Part 1: Introduction"},"content":"Game of Life on Wikipedia\n\nGame of life on Stanford Univ.","type":"content","url":"/game-of-life-tutorial#further-readings","position":7},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 2: Counting living Moore neighbors"},"type":"lvl2","url":"/game-of-life-tutorial#part-2-counting-living-moore-neighbors","position":8},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 2: Counting living Moore neighbors"},"content":"\n\nOur goal is to animate the game of life at a sufficient speed. Typically, a 200x200 grid should be able to be run in real time, i.e. 25 frames per second.\nThe speed of your code execution must therefore be sufficient.\nTry counting Moore’s living neighbors on a small grid at first before moving to a larger one.\n\n%matplotlib widget\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import animation, rc, cm\n\nrc(\"animation\", html=\"html5\")\n\n\n\nWe can easily create a random binary matrix usin numpy\n\ncells = np.random.randint(2, size=(5, 5))\ncells\n\n\n\nplt.figure()\nplt.imshow(cells, cmap=cm.gray)\nplt.colorbar()\nplt.show()\n\n\n\nNow, you need to find a way to calculate the number of living (1) neighbors around every cell.\n\nTips:\n\nTry several methods and determine which one is the best for you,\n\nThe use numpy’s \n\nslicing and striding methods can help,\n\nAlternatively, numba can be an interesting solution in terms of performance, see \n\n5 min to Numba.\n\nBoundary conditions are importants.\n\nNeighbors counts can be stored in a matrix like the following one:\n\nneighbors = np.zeros_like(cells)\nneighbors\n\n\n\n## Part 2: Creating a class\n\nIn what follows, we propose to model the game of life by a class of which the method of calculation of the neighbors that you have just written would be a method.\nHere is a basic code snippet that you can use as inspiration to move forward.\n\nclass GoL:\n    \"\"\"\n    A game of life class.\n    \"\"\"\n\n    def __init__(self, cells):\n        self.cells = np.array(cells)\n\n    def __repr__(self):\n        return \"<GoL with {0} cells>\".format(self.cells.size)\n\n    def count_living_neighbors(self):\n        \"\"\"\n        Counts the number of living neighbors of each cell.\n        \"\"\"\n        # to be completed.\n        return\n\n    def evolve(self):\n        \"\"\"\n        make an evolution step forward.\n        \"\"\"\n        # to be completed.\n        return\n\n\ng = GoL(cells)\ng\n\n\n\n","type":"content","url":"/game-of-life-tutorial#part-2-counting-living-moore-neighbors","position":9},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 3: Animate your Game of Life !"},"type":"lvl2","url":"/game-of-life-tutorial#part-3-animate-your-game-of-life","position":10},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl2":"Part 3: Animate your Game of Life !"},"content":"In the following example, we provide you with a class which is not related to the game of life but which consists of similar methods. It shows how to make an animation. Use it as an inspiration to animate your game of life.\n\nclass AliasingImage:\n    \"\"\"\n    Creates a aliasing illusion.\n    \"\"\"\n\n    def __init__(self, size=(5, 5), depth=8):\n        self.size = size\n        self.depth = depth\n        lx, ly = size\n        x = np.arange(lx)\n        y = np.arange(ly)\n        self.f = 1.0\n        self.df = 0.07\n        self.X, self.Y = np.meshgrid(x, y)\n        self.evolve()\n\n    def evolve(self):\n        \"\"\"\n        Randomizes the image\n        \"\"\"\n        f = self.f\n        self.image = np.cos(2 * f * self.X) * np.sin(2 * f * self.Y)\n        self.f += self.df\n\n\nri = AliasingImage(size=(50, 50))\n\n\ndef updatefig(*args):\n    ri.evolve()\n    im.set_array(ri.image)\n    return (im,)\n\n\nfig, ax = plt.subplots()\nax.axis(\"off\")\nim = plt.imshow(ri.image, interpolation=\"nearest\", cmap=cm.gray, animated=True)\nanim = animation.FuncAnimation(fig, updatefig, frames=40, interval=50, blit=True)\n# plt.show()\nplt.close()\nanim\n\n\n\n","type":"content","url":"/game-of-life-tutorial#part-3-animate-your-game-of-life","position":11},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"Part 4: Other rules","lvl2":"Part 3: Animate your Game of Life !"},"type":"lvl3","url":"/game-of-life-tutorial#part-4-other-rules","position":12},{"hierarchy":{"lvl1":"Conway’s Game of Life","lvl3":"Part 4: Other rules","lvl2":"Part 3: Animate your Game of Life !"},"content":"The game of life can be generalized and \n\nother rules give surprising and interesting results from a mathematical point of view. Some of them include simple structures capable of cloning themselves, which reminds us of DNA in chemistry.\n\nModify your work in order to be able to simulate other rules easily.","type":"content","url":"/game-of-life-tutorial#part-4-other-rules","position":13},{"hierarchy":{"lvl1":"Python basics"},"type":"lvl1","url":"/python-basics","position":0},{"hierarchy":{"lvl1":"Python basics"},"content":"Python is a straightforward language to learn, it is open-source and it is the \n\nmost widely used language in the scientific domain.\nWith this in mind, the goal of this chapter is to familiarize you with the use of Python in the scientific domain.\n\nPOSITRON: PythOn for Science In The Reblochon cOuNtry\n\nSetup your laptop\n\nInstalling Python\n\nBasics\n\nPython basics\n\nScientific Python\n\nAdvanced plotting\n\nExamples\n\nGame of Life and other cellular automatons\n\nExercises\n\nConway’s Game of Life\n\nImage\n\nSupport material\n\nBasics\n\nOrientation an aspect ratio\n\nExercices\n\nTutorial: Counting objects using labeling\n\nPractical Work: Steel microstructure\n\nPractical Work Bonus: Play with dice\n\nData\n\nSupport material\n\nIntroduction\n\nLinear regression - Linear model\n\nLinear regression - Advanced model\n\nDerivation of numerical data\n\nRessources\n\nWord Generator\n\nExercices\n\nAnalysis of data from a weather station\n\nTensile test analysis\n\nODE\n\nSupport material\n\nRessources\n\nModelling the trajectory of a badminton shuttlecock\n\nSimulation of a set of bodies subjected to gravity\n\nMolecular Dynamics : simulation of a crystal formation in 2D\n\nExercices\n\nSimple pendulum\n\nDriven Harmonic Oscillator\n\nVibrational energy harvesting using a Duffing oscillator\n\nOptimization\n\nSupport material\n\nRessources\n\nInteractive optimization\n\nIllustration : Crossing a river\n\nStep by step Optimization : understanding gradient based method\n\nExercices\n\nRosenbrock function and Curve fiting\n\nOptimizing a bridge structure\n\nMachine Learning\n\nSupport material\n\nExercices\n\nSupervised learning using PyTorch: a toy example\n\nReinforcement learning on snake with a genetic neural network","type":"content","url":"/python-basics","position":1},{"hierarchy":{"lvl1":"Advanced plotting"},"type":"lvl1","url":"/plotting","position":0},{"hierarchy":{"lvl1":"Advanced plotting"},"content":"# UNCOMMENT FOR INTERACTIVE PLOTS\n# %matplotlib notebook\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nfrom matplotlib import cm\n\n\n\ndef func(x, y):\n    \"\"\"\n    A nice looking mapping.\n    \"\"\"\n    r = (x**2 + y**2) ** 0.5\n    theta = np.where(r != 0.0, np.arccos(x / r) * np.sign(y), 0.0)\n    z = (1.0 / (r + 5.0) ** 0.5) * np.sin(2.0 * np.pi * r / 3.0) * np.cos(4 * theta)\n    return z\n\n\nx = np.linspace(-3.0, 3.0, 101)\ny = np.linspace(-3.0, 3.0, 101)\nX, Y = np.meshgrid(x, y)\nX\n\n\n\nY\n\n\n\nZ = func(X, Y)\n\n\n\nfig = plt.figure(figsize=(8, 6))\nax = fig.add_subplot(1, 1, 1)\nax.set_aspect(\"equal\")\ncont = plt.contourf(X, Y, Z, 10, cmap=cm.jet)\ncbar = plt.colorbar(cont)\ncbar.set_label(\"Amplitude, $z$\")\nplt.xlabel(\"Position, $x$\")\nplt.ylabel(\"Position, $y$\")\nplt.contour(X, Y, Z, 10, colors=\"black\")\nplt.show()\n\n","type":"content","url":"/plotting","position":1},{"hierarchy":{"lvl1":"Scientific Python"},"type":"lvl1","url":"/scientific-python","position":0},{"hierarchy":{"lvl1":"Scientific Python"},"content":"Python is versatile environment but it does not provide the right tools for scientific usage without some key packages:\n\nNumPy (\n\nhttp://​www​.numpy​.org/): improves dramatically python’s numerical analysis capabilities.\n\nSciPy (\n\nhttps://​www​.scipy​.org/): provides all classical scientific algorithm.\n\nMatPlotLib (\n\nhttps://​matplotlib​.org​/gallery​/index​.html: high quality scientific plotting.\n\nPandas (\n\nhttps://​pandas​.pydata​.org/): fast and efficient data processing","type":"content","url":"/scientific-python","position":1},{"hierarchy":{"lvl1":"Scientific Python","lvl2":"A short introduction: plotting a function"},"type":"lvl2","url":"/scientific-python#a-short-introduction-plotting-a-function","position":2},{"hierarchy":{"lvl1":"Scientific Python","lvl2":"A short introduction: plotting a function"},"content":"\n\n# UNCOMMENT FOR INTERACTIVE PLOTS\n# %matplotlib notebook\nimport numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n\n\ndef func(t, damp=1.0, freq=1.0, phase=0.0):\n    \"\"\"\n    The solution of a second order linear ordinary differential equation:\n\n    func(t) = exp(-t * damp) * cos(2 * pi * f * t + phase)\n\n    Inputs:\n    * damp: dampening coefficient.\n    * freq: frequency\n    * phase: the phase of the signal\n\n    Ouput: data as a DataFrame for easier post processing.\n    \"\"\"\n    return pd.DataFrame(\n        {\"a\": np.exp(-t * damp) * np.cos(2.0 * np.pi * freq * t + phase), \"t\": t}\n    )\n\n\nt = np.linspace(0.0, 5.0, 1001)\ndata = func(t, damp=0.1, freq=1.0)\ndata.head()\n\n\n\nplt.figure(figsize=(8, 6))\nfor f in [1.0, 0.5, 0.25]:\n    data = func(t, damp=0.2, freq=f)\n    plt.plot(data.t, data.a, label=\"$f={0}$\".format(f))\ndata = func(t, damp=0.2, freq=0)\nplt.plot(data.t, data.a, \"k--\", label=\"Enveloppe\")\nplt.plot(data.t, -data.a, \"k--\")\nplt.grid()\nplt.legend(loc=\"best\")\nplt.xlabel(\"Time, $t$\")\nplt.ylabel(\"Amplitude, $a$\")\nplt.title(r\"A damped harmonic oscillator: $a(t) = \\exp(-t d) \\cos (2 \\pi f t + \\phi)$\")\nplt.show()\n\n\n\nFurther readings:\n\nhttp://​www​.scipy​-lectures​.org​/intro​/intro​.html​#the​-scientific​-python​-ecosystem\n\nhttps://​www​.scipy​.org​/about​.html\n\nhttps://​www​.stat​.washington​.edu​/​~hoytak​/blog​/whypython​.html","type":"content","url":"/scientific-python#a-short-introduction-plotting-a-function","position":3},{"hierarchy":{"lvl1":"Installing Python"},"type":"lvl1","url":"/setup","position":0},{"hierarchy":{"lvl1":"Installing Python"},"content":"","type":"content","url":"/setup","position":1},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Install Miniforge"},"type":"lvl3","url":"/setup#install-miniforge","position":2},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Install Miniforge"},"content":"As of January 2025, we recommend installing Miniforge rather than Anaconda, for reasons of simplicity and licensing:\n\nMiniforge installer, you may need to have a look at the \n\nMiniforge documentation for more information.\nMamba is already included in Miniforge.\n\nFor Windows users only\n\nIf you do so, it is important that you chose 2 options during installation:\n\ninstall only for me and\n\nadd mini-forge to your PATH.","type":"content","url":"/setup#install-miniforge","position":3},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Environment setup"},"type":"lvl3","url":"/setup#environment-setup","position":4},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Environment setup"},"content":"Create an environment with the following command:\n\nDownload the environment file \n\npositron_env.yaml and put it in the current folder.\n\nRun the following command:mamba env create --file=positron_env.yaml\n\nIf you don’t have mamba installed, you can use conda instead:conda env create --file=positron_env.yaml\n\nThe install process will just be a bit slower.\n\nActivate the environment:conda activate positron","type":"content","url":"/setup#environment-setup","position":5},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Run all examples locally"},"type":"lvl3","url":"/setup#run-all-examples-locally","position":6},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Run all examples locally"},"content":"At this point, you should have all the necessary packages installed. You can run Jupyter Lab with the following command:jupyter lab\n\nAnd Jupyter Notebook with:jupyter notebook","type":"content","url":"/setup#run-all-examples-locally","position":7},{"hierarchy":{"lvl1":"Installing Python","lvl2":"Installing GIT"},"type":"lvl2","url":"/setup#installing-git","position":8},{"hierarchy":{"lvl1":"Installing Python","lvl2":"Installing GIT"},"content":"If you’re new to Python, learning Git is a game-changer!\nIt helps you track changes, undo mistakes, and collaborate easily.\nWith GitHub or GitLab, you can contribute to open-source projects and showcase your work.\nStart using Git early—it’ll make your coding journey way smoother!","type":"content","url":"/setup#installing-git","position":9},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Procedure","lvl2":"Installing GIT"},"type":"lvl3","url":"/setup#procedure","position":10},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Procedure","lvl2":"Installing GIT"},"content":"For Windows users: \n\nGIT-SCM\n\nLinux: GIT is already instlalled\n\nMAC OS: for example, install it via Brew  \n\nbrew install git","type":"content","url":"/setup#procedure","position":11},{"hierarchy":{"lvl1":"Installing Python","lvl2":"Installing VSCode"},"type":"lvl2","url":"/setup#installing-vscode","position":12},{"hierarchy":{"lvl1":"Installing Python","lvl2":"Installing VSCode"},"content":"Visual Studio Code (VSCode) is a lightweight but powerful source code editor that runs on your desktop.","type":"content","url":"/setup#installing-vscode","position":13},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Procedure","lvl2":"Installing VSCode"},"type":"lvl3","url":"/setup#procedure-1","position":14},{"hierarchy":{"lvl1":"Installing Python","lvl3":"Procedure","lvl2":"Installing VSCode"},"content":"Download the installer from the \n\nVSCode website.\n\nRun the installer and follow the instructions.\n\nFor Windows users only\n\nChose the “system installer” and not the “user installer”.\n\nOpen VSCode and install the Python extension by Microsoft.","type":"content","url":"/setup#procedure-1","position":15}]}